@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"

    try:
        with IMAPClient(HOST, ssl_context=ssl_context, port=993) as server:
            server.login(USERNAME, PASSWORD)
            imap_server = server.select_folder('INBOX')

            # Search for the unread emails
            unseen_mails = server.search(["UNSEEN"])
            print(unseen_mails)

            if unseen_mails:
                mail_id = str(unseen_mails[0]).split()[0]
                try:
                    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                    email_body = email_data[0][1].decode("utf-8")
                except:
                    print("Error fetching email with ID:", mail_id)
                else:
                    # Extract the trade parameters from the email
                    account_side = re.search(r'Account side: (.*)', email_body).group(1)
                    account_symbol = re.search(
                        r'Account symbol: (.*)', email_body).group(1)
                    account_order_type = re.search(
                        r'Order type: (.*)', email_body).group(1)
                    account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
                    account_price = re.search(r'Order price: (.*)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)
                    passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
                    timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)

                    # Mark the email as seen
                    imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])

                    # Perform the trade execution steps here
                    # ...
            else:
                print("No unread emails found")
    except Exception as e:
        print("Error connecting to the IMAP server:", str(e))

    try:
        imap_server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))


















app = Flask(__name__)


@app.route('/e')

def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
HOST = "outlook.office365.com"
USERNAME = "sterxus@outlook.com"
PASSWORD = "TheMando321!"
   try:
        with IMAPClient(HOST, ssl_context=ssl_context, port=993) as server:
     server.login(USERNAME, PASSWORD)
     imap_server = server.select_folder('INBOX')

    # Search for the unread emails
        unseen_mails = server.search(["UNSEEN"])
        print(unseen_mails)

    if unseen_mails:
        mail_id = str(unseen_mails[0]).split()[0]
    try:
        _, email_data = imap_server.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")
    except:
        print("Error fetching email with ID:", mail_id)
        return

    else:
        print("No unread emails found")
        return
except Exception as e:
    print("Error connecting to the IMAP server:", str(e))
    return

# Perform the trade execution steps here
# ...

try:
    imap_server.logout()
except Exception as e:
    print("Error logging out from the IMAP server:", str(e))
    return

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(
            r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(
            r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(
            r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(
            r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")




else:
            print("No unread emails found")
            return
except Exception as e:
    print("Error connecting to the IMAP server:", str(e))
    return

# Perform the trade execution steps here
# ...

try:
    imap_server.logout()
except Exception as e:
    print("Error logging out from the IMAP server:", str(e))
    return













[6031, 6179, 6181, 6183]
Error fetching email with ID: 6031
[2023-01-31 01:47:00,574] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/py/app.py", line 31, in execute_trade
    _, email_data = server.fetch(mail_id, "(RFC822)")
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1383, in fetch
    tag = self._imap._command(*args)
  File "/usr/lib/python3.10/imaplib.py", line 968, in _command
    raise self.error("command %s illegal in state %s, "
imaplib.IMAP4.error: command UID illegal in state LOGOUT, only allowed in states SELECTED

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/lib/python3.10/imaplib.py", line 1006, in _command
    self.send(data + CRLF)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/tls.py", line 62, in send
    self.sock.sendall(data)
  File "/usr/lib/python3.10/ssl.py", line 1240, in sendall
    return super().sendall(data, flags)
OSError: [Errno 9] Bad file descriptor

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 35, in execute_trade
    server.logout()
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 513, in logout
    typ, data = self._imap.logout()
  File "/usr/lib/python3.10/imaplib.py", line 642, in logout
    typ, dat = self._simple_command('LOGOUT')
  File "/usr/lib/python3.10/imaplib.py", line 1230, in _simple_command
    return self._command_complete(name, self._command(name, *args))
  File "/usr/lib/python3.10/imaplib.py", line 1008, in _command
    raise self.abort('socket error: %s' % val)
imaplib.IMAP4.abort: socket error: [Errno 9] Bad file descriptor




im getting these errors in my script below can you give me a fix
2023-01-31 01:33:46,791] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 26, in execute_trade
    unseen_mails = imap_server.search(["UNSEEN"])
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1115, in search
    return self._search(criteria, charset)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1141, in _search
    data = self._raw_command_untagged(b"SEARCH", args)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1639, in _raw_command_untagged
    typ, data = self._raw_command(command, args, uid=uid)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1697, in _raw_command
    self._imap.send(out)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/tls.py", line 62, in send
    self.sock.sendall(data)
  File "/usr/lib/python3.10/ssl.py", line 1240, in sendall
    return super().sendall(data, flags)
OSError: [Errno 9] Bad file descriptor
server.select_folder('INBOX')
[2023-01-31 01:26:27,168] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 25, in execute_trade
    unseen_mails = imap_server.search(["UNSEEN"])
AttributeError: 'dict' object has no attribute 'search'
def execute_trade():
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    with IMAPClient(HOST, ssl_context=ssl_context, port=993) as server:
        server.login(USERNAME, PASSWORD)
        imap_server = server.select_folder('INBOX')

    # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])

    if unseen_mails:
        mail_id = str(unseen_mails[0]).split()[0]
        try:
            _, email_data = imap_server.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode("utf-8")
        except:
            print("Error fetching email with ID:", mail_id)
            imap_server.logout()
            return "Error fetching email with ID: " + mail_id





@app.route('/e')
def execute_trade():
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    with IMAPClient(HOST, ssl_context=ssl_context,port =993) as server:
        server.login(USERNAME, PASSWORD)
    imap_server = server.select_folder('INBOX')

    # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])

    if unseen_mails:
        mail_id = str(unseen_mails[0]).split()[0]
        try:
            _, email_data = imap_server.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode("utf-8")
        except:
            print("Error fetching email with ID:", mail_id)
            imap_server.logout()
            return "Error fetching email with ID: " + mail_id

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")
        imap_server.log
        imap_server.logout()

    # Initialize the Bybit client
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type, qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())   
# get the order ID from the response
        print(client.Order.Order_getOrders(symbol=account_symbol).result())


with IMAPClient(HOST, ssl_context=ssl_context) as server:
    server.login(USERNAME, PASSWORD)



   ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True, ssl_context=ssl_context)
imap_server.login('sterxus@outlook.com', 'TheMando321!')
imap_server.select_folder('INBOX')
   
   
   
   
   
   
   
   
   
   
   
   
   imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

    # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])

    if unseen_mails:
        mail_id = str(unseen_mails[0]).split()[0]
        try:
            _, email_data = imap_server.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode("utf-8")
        except:
            print("Error fetching email with ID:", mail_id)
            imap_server.logout()
            return "Error fetching email with ID: " + mail_id

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")
        imap_server.log



























Can you fix these errros in the script below:       
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 23, in execute_trade
    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1384, in fetch
    typ, data = self._imap._command_complete("FETCH", tag)
  File "/usr/lib/python3.10/imaplib.py", line 1055, in _command_complete
    raise self.error('%s command error: %s %s' % (name, typ, data))
imaplib.IMAP4.error: FETCH command error: BAD [b'Command Argument Error. 11']
from flask import Flask
import json
import bybit
import time
import re
from imapclient import IMAPClient


app = Flask(__name__)


@app.route('/e')
def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

   # Search for the unread emails

    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails and unseen_mails[0]:
        mail_id = str(unseen_mails[0]).split()[0]
        _, email_data = imap_server.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")
        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()

    # Initialize the Bybit client
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
    print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
          qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())   
# get the order ID from the response
    print(client.Order.Order_getOrders(symbol=account_symbol).result())

# Cancel the order
#print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
#print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
#print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
    print(client.Order.Order_query(symbol=account_symbol).result())

# My Position
    print(client.Positions.Positions_myPosition(symbol=account_symbol).result())

if __name__ == '__main__':
    app.run()

# If the order is filled, print a message
#if _myPosition == True:
#    print("Order Active")
#else:
#   print("Order not filled.")







unseen_mails = imap_server.search(["UNSEEN"])
if unseen_mails and unseen_mails[0]:
    mail_id = str(unseen_mails[0]).split()[0https://github.com/skulzz/LONG-SHORT-BOT-WITH-DUAL-TRADES/blame/main/oraganized]
    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode("utf-8")











2023-01-30 22:49:54,694] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 21, in execute_trade
    mail_id = unseen_mails[0].decode().split()[0]
AttributeError: 'int' object has no attribute 'decode'













404 -
[2023-01-30 22:29:26,795] ERROR in app: Exception on / [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 21, in execute_trade
    mail_id = unseen_mails[0].split()[0]
AttributeError: 'int' object has no attribute 'split'
from flask import Flask
import json
import bybit
import time
import re
from imapclient import IMAPClient


app = Flask(__name__)


@app.route('/e')
def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

   # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails[0] != b'':
        mail_id = unseen_mails[0].split()[0]
        _, email_data = imap_server.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()

    # Initialize the Bybit client
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
    print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
          qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())   
# get the order ID from the response
    print(client.Order.Order_getOrders(symbol=account_symbol).result())

# Cancel the order
#print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
#print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
#print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
    print(client.Order.Order_query(symbol=account_symbol).result())

# My Position
    print(client.Positions.Positions_myPosition(symbol=account_symbol).result())

if __name__ == '__main__':
    app.run()

# If the order is filled, print a message
#if _myPosition == True:
#    print("Order Active")
#else:
#   print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails[0] != b'':
        mail_id = unseen_mails[0].split()[0]
        _, email_data = imap_server.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(


        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()

    # Initialize the Bybit client
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                         api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    # Place the order
    print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
          qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())














    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails:
        mail_id = list(unseen_mails)[0]
        email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
        email_body = email_data.get_body().decode()
        passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
        strategy_position_size = re.search(
            r'Position size: (.*)', email_body).group(1)
        strategy_order_action = re.search(
            r'Order action: (.*)', email_body).group(1)
        strategy_order_contracts = re.search(
            r'Order contracts: (.*)', email_body).group(1)
        strategy_order_price = re.search(
            r'Order price: (.*)', email_body).group(1)
        strategy_order_id = re.search(
            r'Order ID: (.*)', email_body).group(1)
        strategy_market_position = re.search(
            r'Market position: (.*)', email_body).group(1)
        strategy_prev_market_position = re.search(
            r'Previous market position: (.*)', email_body).group(1)
        strategy_prev_market_position_size = re.search(
            r'Previous market position size: (.*)', email_body).group(1)
        strategy_account_side = re.search(
            r'Account side: (.*)', email_body).group(1)
        strategy_account_symbol = re.search(
            r'Account side: (.*)', email_body).group(1)
        strategy_account_side = re.search(
            r'Account side: (.*)', email_body).group(1)

        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()
    return "OK"

# Initialize the Bybit client
client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                     api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

# Place the order
print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
      qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
















@app.route('/')
def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails:
        mail_id = list(unseen_mails)[0]
        email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
        email_body = email_data.get_body().decode()
        passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
        strategy_position_size = re.search(
            r'Position size: (.*)', email_body).group(1)
        strategy_order_action = re.search(
            r'Order action: (.*)', email_body).group(1)
        strategy_order_contracts = re.search(
            r'Order contracts: (.*)', email_body).group(1)
        strategy_order_price = re.search(
            r'Order price: (.*)', email_body).group(1)
        strategy_order_id = re.search(
            r'Order ID: (.*)', email_body).group(1)
        strategy_market_position = re.search(
            r'Market position: (.*)', email_body).group(1)
        strategy_market_position_size = re.search(
            r'Market position size: (.*)', email_body).group(1)
        strategy_prev_market_position = re.search(
            r'Previous market position: (.*)', email_body).group(1)
        strategy_prev_market_position_size = re.search(
            r'Previous market position size: (.*)', email_body).group(1)

        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()
    return "OK"

if __name__ == '__main__':
    app.run()

# Initialize the Bybit client
client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                     api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
























app = Flask(__name__)


@app.route('/')
def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

    while True:
        unseen_mails = imap_server.search(["UNSEEN"])
        if unseen_mails:
            mail_id = list(unseen_mails)[0]
            email_id, email_data = imap_server.fetch(
                mail_id, 'RFC822').popitem()
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(
                r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(
                r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(
                r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(
                r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(
                r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(
                r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(
                r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(
                r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(
                r'Previous market position size: (.*)', email_body).group(1)
        else:
            print("No messages found")

        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
        time.sleep(5)
        imap_server.logout()


json_data = {
    "passphrase": "a321!",
    "timeframe": "2023-01-01T12:00:00",
    "exchange": "abc",
    "ticker": "abc_123",
    "bar": {
        "time": "2023-01-01T12:00:00",
        "open": 100.0,
        "high": 101.0,
        "low": 99.0,
        "close": 100.5,
        "volume": 1000
    },
    "strategy": {
        "position_size": 100,
        "order_action": "buy",
        "order_contracts": 5,
        "order_price": 100.0,
        "order_id": 123456,
        "market_position": "long"
    },
    "account": {
        "side": "buy",
        "symbol": "abc_123",
        "order_type": "limit",
        "qty": 5,
        "price": 100.0,
        "time_in_force": "gtc"
    }
}

data = '{"passphrase": "a321!", "timeframe": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'
# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
timeframe = json_data["timeframe"]
exchange = json_data["exchange"]
symbol = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
strategy_position_size = strategy.get("position_size", "")
strategy_order_action = strategy.get("order_action", "")
strategy_order_contracts = strategy.get("order_contracts", "")
strategy_order_price = strategy.get("order_price", "")
strategy_order_id = strategy.get("order_id", "")
strategy_market_position = strategy.get("market_position", "")
strategy_market_position_size = strategy.get("market_position_size", "")
strategy_prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
account_side = account.get("side", "")
account_symbol = account.get("symbol", "")
account_order_type = account.get("order_type", "")
account_qty = account.get("qty", 0)
account_price = account.get("price", 0.0)
account_time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Timeframe:", timeframe)
print("Exchange:", exchange)
print("Ticker:", symbol)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", strategy_position_size)
print("Order Action:", strategy_order_action)
print("Order Contracts:", strategy_order_contracts)
print("Order Price:", strategy_order_price)
print("Order ID:", strategy_order_id)
print("Market Position:", strategy_market_position)
print("Market Position Size:", strategy_market_position_size)
print("Prev Market Position:", strategy_prev_market_position)
print("Side:", account_side)
print("Symbol:", account_symbol)
print("Order Type:", account_order_type)
print("Qty:", account_qty)
print("Price:", account_price)
print("Time In Force:", account_time_in_force)
# Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()


json_data = json.loads(data)

ccount_symbol = json_data["ticker"]
account_side = account.get("side", "")
account_order_type = account.get("order_type", "")
account_qty = account.get("qty", "")
account_price = account.get("price", "")
account_time_in_force = account.get("time_in_force", "")
saccount_trategy = account.get("strategy", "")

# Initialize the Bybit client
client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                     api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

# Place the order
print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
      qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())

# get the order ID from the response
response = client.Order.Order_getOrders(symbol=account_symbol).result()

# Cancel the order
#print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
#print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
#print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
print(client.Order.Order_query(symbol=account_symbol).result())

# My Position
print(client.Positions.Positions_myPosition(symbol=account_symbol).result())

# If the order is filled, print a message
#if _myPosition == True:
#    print("Order Active")
#else:
#   print("Order not filled.")










# get the order ID from the response
response = client.Order.Order_getOrders(symbol=account_symbol).result()
order_id = response[0]["order_id"]





account_symbol = json_data["ticker"]
account_side = account.get("side", "")
account_order_type = account.get("order_type", "")
account_qty = account.get("qty", "")
account_price = account.get("price", "")
account_time_in_force = account.get("time_in_force", "")
saccount_trategy = account.get("strategy", "")












json_data = {
    "passphrase": "a321!",
    "timeframe": "2023-01-01T12:00:00",
    "exchange": "abc",
    "ticker": "abc_123",
    "bar": {
        "time": "2023-01-01T12:00:00",
        "open": 100.0,
        "high": 101.0,
        "low": 99.0,
        "close": 100.5,
        "volume": 1000
    },
    "strategy": {
        "position_size": 100,
        "order_action": "buy",
        "order_contracts": 5,
        "order_price": 100.0,
        "order_id": 123456,
        "market_position": "long"
    },
    "account": {
        "side": "buy",
        "symbol": "abc_123",
        "order_type": "limit",
        "qty": 5,
        "price": 100.0,
        "time_in_force": "gtc"
    }
}

data = '{"passphrase": "a321!", "timeframe": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'
# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
timeframe = json_data["timeframe"]
exchange = json_data["exchange"]
symbol = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
strategy_position_size = strategy.get("position_size", "")
strategy_order_action = strategy.get("order_action", "")
strategy_order_contracts = strategy.get("order_contracts", "")
strategy_order_price = strategy.get("order_price", "")
strategy_order_id = strategy.get("order_id", "")
strategy_market_position = strategy.get("market_position", "")
strategy_market_position_size = strategy.get("market_position_size", "")
strategy_prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
account_side = account.get("side", "")
account_symbol = account.get("symbol", "")
account_order_type = account.get("order_type", "")
account_qty = account.get("qty", 0)
account_price = account.get("price", 0.0)
account_time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Timeframe:", timeframe)
print("Exchange:", exchange)
print("Ticker:", symbol)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", strategy_position_size)
print("Order Action:", strategy_order_action)
print("Order Contracts:", strategy_order_contracts)
print("Order Price:", strategy_order_price)
print("Order ID:", strategy_order_id)
print("Market Position:", strategy_market_position)
print("Market Position Size:", strategy_market_position_size)
print("Prev Market Position:", strategy_prev_market_position)
print("Side:", account_side)
print("Symbol:", account_symbol)
print("Order Type:", account_order_type)
print("Qty:", account_qty)
print("Price:", account_price)
print("Time In Force:", account_time_in_force)
# Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()


json_data = json.loads(data)

account_symbol = json_data["ticker"]
account_side = json_data["side"]
account_order_type = json_data["order_type"]
account_qty = json_data["qty"]
account_price = json_data["price"]
account_time_in_force = json_data["time_in_force"]
saccount_trategy = json_data["strategy"]








json_data = {
    "passphrase": "a321!", 
    "time": "2023-01-01T12:00:00", 
    "exchange": "abc", 
    "ticker": "abc_123", 
    "bar": {
        "time": "2023-01-01T12:00:00", 
        "open": 100.0, 
        "high": 101.0, 
        "low": 99.0, 
        "close": 100.5, 
        "volume": 1000
    }, 
    "strategy": {
        "position_size": 100, 
        "order_action": "buy", 
        "order_contracts": 5, 
        "order_price": 100.0, 
        "order_id": 123456, 
        "market_position": "long"
    }, 
    "account": {
        "side": "buy", 
        "symbol": "abc_123", 
        "order_type": "limit", 
        "qty": 5, 
        "price": 100.0, 
        "time_in_force": "gtc"
    }
}
















def execute_trade():  
    imap_server = IMAPClient('imap-mail.outlook.com',993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')
    
    while True:
        unseen_mails = imap_server.search(["UNSEEN"])
        if unseen_mails:
            mail_id = list(unseen_mails)[0]
            email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(
                r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(
                r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(
                r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(
                r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(
                r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(
                r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(
                r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(
                r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(
                r'Previous market position size: (.*)', email_body).group(1)
        else:
            print("No messages found")
        
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
        time.sleep(5)
    imap_server.logout()

json_data = {
"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": { 
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
        "close": "{{close}}",
        "volume": "{{volume}}",
},
"order": {
     "side": "side",
     "symbol": "symbol",
     "type": "Limit",
     "qty": "qty",
     "price": "price",
     "time_in_force": "gtc"
},
"passphrase": "{{passphrase}}"
}

data = '{"passphrase": "a321!", "time": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'
# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
time1 = json_data["time"]
exchange = json_data["exchange"]
symbol = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
position_size = strategy.get("position_size", "")
order_action = strategy.get("order_action", "")
order_contracts = strategy.get("order_contracts", "")
order_price = strategy.get("order_price", "")
order_id = strategy.get("order_id", "")
market_position = strategy.get("market_position", "")
market_position_size = strategy.get("market_position_size", "")
prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
side = account.get("side", "")
symbol = account.get("symbol", "")
order_type = account.get("order_type", "")
qty = account.get("qty", "")
price = account.get("price", "")
time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Time:", time)
print("Exchange:", exchange)
print("Ticker:", symbol)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", position_size)
print("Order Action:", order_action)
print("Order Contracts:", order_contracts)
print("Order Price:", order_price)
print("Order ID:", order_id)
print("Market Position:", market_position)
print("Market Position Size:", market_position_size)
print("Prev Market Position:", prev_market_position)
print("Side:", side)
print("Symbol:", symbol)
print("Order Type:", order_type)
print("Qty:", qty)
print("Price:", price)
print("Time In Force:", time_in_force)
# Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()

with open("json_data") as f:
    json_data = json.load(f)

symbol = json_data["symbol"]
order_side = json_data["side"]
order_type = json_data["order_type"]
qty = json_data["qty"]
price = json_data["price"]
time_in_force = json_data["time_in_force"]
strategy = json_data["strategy"]



















with open("json_data", "r") as f:
json_data = json.load(f)

symbol = json_data["symbol"]
order_side = json_data["side"]
order_type = json_data["order_type"]
qty = json_data["qty"]
price = json_data["price"]
time_in_force = json_data["time_in_force"]
strategy = json_data["strategy"]












symbol_json_data = json.load(data)
symbol = symbol_json_data["symbol"]

with open("json_data", "r") as f:
order_side_json_data = json.load(f)
order_side = order_side_json_data["side"]

with open("json_data", "r") as f:
order_type_json_data = json.load(f)
order_type = order_type_json_data["order_type"]

with open("json_data", "r") as f:
qty_json_data = json.load(f)
qty = qty_json_data["qty"]

with open("json_data", "r") as f:
price_json_data = json.load(f)
price = price_json_data["price"]

with open("json_data", "r") as f:
time_in_force_json_data = json.load(f)
time_in_force = time_in_force_json_data["time_in_force"]

strategy = json_data["strategy"]

Initialize the Bybit client
client = bybit.bybit(test=False, api_key= "76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

Place the order
print(client.Order.Order_new(side=order_side, symbol=symbol, order_type=order_type, qty=qty, price=price, time_in_force=time_in_force).result())

Get the order ID from the response
response = client.Order.Order_getOrders(symbol=symbol).result()
order_id = response[0]["order_id"]

Cancel the order
print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

Cancel All Active Orders
print(client.Order.Order_cancelAll(symbol=symbol).result())

Replace Active Order
print(client.Order.Order_replace(symbol=symbol, order_id=order_id, p_r_qty=qty).result())
#Query Active Orders(real-time)
print(client.Order.Order_query(symbol=symbol, order_id=order_id).result())

My Position
my_position = client.Positions.Positions_myPosition(symbol=symbol).result()

If the order is filled, print a message
if my_position == True:
print("Order Active")
else:
print("Order not filled.")




























symbol_json_data = json.load(data)
symbol = symbol_json_data["symbol"]

with open("json_data") as f:
     order_side_json_data = json.load(f)
     order_side = order_side_json_data["side"]

with open("json_data") as f:
    order_type_json_data = json.load(f)
    order_type = order_type_json_data["order_type"]

with open("json_data") as f:
    qty_json_data = json.load(f)
qty = qty_json_data["qty"]

with open("json_data") as f:
     price_json_data = json.load(f)
     price = price_json_data["price"]

with open("json_data") as f:
     time_in_force_json_data = json.load(f)
     time_in_force = time_in_force_json_data["time_in_force"]

strategy = json_data["strategy"]

## Initialize the Bybit client
client = bybit.bybit(test=False, api_key= "76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
print(client.Order.Order_getOrders(symbol="symbol").result())
#order_id = response[0]
# Cancel the order
# print(client.Order.Order_cancel(symbol="symbol", order_id=order_id).result())
# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol="BTCUSD").result())
# Replace Active Order
# print(client.Order.Order_replace(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec", p_r_qty="3").result())
#Query Active Orders(real-time)
#print(client.Order.Order_query(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec").result())
#status = order_details["result"]["order_status"]
# My Position
print(client.Positions.Positions_myPosition(symbol="symbol").result())
# If the order is filled, print a message
#if myPosition == True:
#    print("Order Active")
#else:
#    print("Order not filled.")














def execute_trade():  
    imap_server = IMAPClient('outlook.office365.com',993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')
    
    while True:
        unseen_mails = imap_server.search("UNSEEN")
        if unseen_mails:
            mail_id = list(unseen_mails)[0]
            email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(
                r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(
                r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(
                r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(
                r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(
                r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(
                r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(
                r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(
                r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(
                r'Previous market position size: (.*)', email_body).group(1)
        else:
            print("No messages found")
        
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
        time.sleep(5)
    imap_server.logout()

json_data = {
"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": { 
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
        "close": "{{close}}",
        "volume": "{{volume}}",
},
"order": {
     "side": "side",
     "symbol": "symbol",
     "type": "Limit",
     "qty": "qty",
     "price": "price",
     "time_in_force






















Traceback (most recent call last):
  File "/home/j/.local/bin/flask", line 8, in <module>
    sys.exit(main())
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 1047, in main
    cli.main()
  File "/usr/lib/python3/dist-packages/click/core.py", line 1053, in main
    rv = self.invoke(ctx)
  File "/usr/lib/python3/dist-packages/click/core.py", line 1659, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
  File "/usr/lib/python3/dist-packages/click/core.py", line 1395, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "/usr/lib/python3/dist-packages/click/core.py", line 754, in invoke
    return __callback(*args, **kwargs)
  File "/usr/lib/python3/dist-packages/click/decorators.py", line 84, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
  File "/usr/lib/python3/dist-packages/click/core.py", line 754, in invoke
    return __callback(*args, **kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 911, in run_command
    raise e from None
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 897, in run_command
    app = info.load_app()
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 308, in load_app
    app = locate_app(import_name, name)
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 218, in locate_app
    __import__(module_name)
  File "/home/j/py/app.py", line 152, in <module>
    with open("side.json") as f:
FileNotFoundError: [Errno 2] No such file or directory: 'side.json'


"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": { 
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
        "close": "{{close}}",
        "volume": "{{volume}}",
},
"order": {
"side": "side",
"symbol": "symbol",
"type": "Limit",
"qty": "qty",
"price": "price",
"time_in_force": "gtc"
},
"passphrase": "{{passphrase}}"
}














"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": {
"timestamp": "{{timestamp}}",
"open": "{{open}}",
"high": "{{high}}",
"low": "{{low}}",
"close": "{{close}}",
"volume": "{{volume}}",
},
"order": {
"side": "side",
"symbol": "symbol",
"type": "Limit",
"qty": "qty",
"price": "price",
"time_in_force": "gtc"
},
"passphrase": "{{passphrase}}"
}
## Initialize the Bybit client
client = bybit.bybit(test=False, api_key= "76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
print(client.Order.Order_getOrders(symbol="symbol").result())
# My Position
print(client.Positions.Positions_myPosition(symbol="symbol").result())
# If the order is filled, print a message


symbol_json_data = json.load(f)
symbol = symbol_json_data["symbol"]

with open("side.json") as f:
side_json_data = json.load(f)
side = side_json_data["side"]

with open("order_type.json") as f:
order_type_json_data = json.load(f)
order_type = order_type_json_data["order_type"]

with open("qty.json") as f:
qty_json_data = json.load(f)
qty = qty_json_data["qty"]

with open("price.json") as f:
price_json_data = json.load(f)
price = price_json_data["price"]

with open("time_in_force.json") as f:
time_in_force_json_data = json.load(f)
time_in_force = time_in_force_json_data["time_in_force"]
    
symbol = json_data["symbol"]
side = json_data["side"]
order_type = json_data["order_type"]
qty = json_data["qty"]
price = json_data["price"]
time_in_force = json_data["time_in_force"]



76QjbsflcrBdSZiSr
SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32p
## Initialize the Bybit client
client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
print(client.Order.Order_getOrders(symbol="symbol").result())


client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
response = client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result()

if response.ret_code == 0:
    print("Order placed successfully")
else:
    print("Order placement failed with error code:", response.ret_code)

# Get the order ID from the response
order_list_response = client.Order.Order_getOrders(symbol="symbol").result()
if order_list_response.ret_code == 0:
    order_id = order_list_response.result[0].order_id
    print("Order ID:", order_id)
else:
    print("Order info retrieval failed with error code:", order_list_response.ret_code)


client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
response = client.Order.Order_getOrders(symbol="symbol").result()
order_id = response[0]

got all these errors
({'ret_code': 10003, 'ret_msg': 'API key is invalid.', 'result': {}, 'ext_code': '', 'ext_info': '', 'time_now': '1675073367.977186', 'rate_limit_status': 0, 'rate_limit': 0, 'rate_limit_reset_ms': 0}, <bravado.requests_client.RequestsResponseAdapter object at 0x7fd50aff40d0>)
Traceback (most recent call last):
  File "/home/j/py/app.py", line 181, in <module>
    order_details = client.Order.Order_query(
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 246, in __call__
    request_params = construct_request(
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 285, in construct_request
    construct_params(operation, request, op_kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 308, in construct_params
    marshal_param(param, param_value, request)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/param.py", line 133, in marshal_param
    validate_schema_object(swagger_spec, param_spec, value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 68, in validate_schema_object
    validate_primitive(swagger_spec, schema_object_spec, value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 43, in scrubbed
    reraise(*sys.exc_info())
  File "/usr/lib/python3/dist-packages/six.py", line 719, in reraise
    raise value
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 35, in scrubbed
    return func(*args, **kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 101, in validate_primitive
    ).validate(value)
  File "/home/j/.local/lib/python3.10/site-packages/jsonschema/validators.py", line 314, in validate
    raise error
jsonschema.exceptions.ValidationError: {'ret_code': 10003, 'ret_msg': 'API key is invalid.', 'result': {}, 'ext_code': '', 'ext_info': '', 'time_now': '1675073368.248223', 'rate_limit_status': 0, 'rate_limit': 0, 'rate_limit_reset_ms': 0} is not of type 'string'

Failed validating 'type' in schema:
    {'description': 'Order ID',
     'in': 'query',
     'name': 'order_id',
     'required': False,
     'type': 'string'}

On instance:
    {'ext_code': '',
     'ext_info': '',
     'rate_limit': 0,
     'rate_limit_reset_ms': 0,
     'rate_limit_status': 0,
     'result': {},
     'ret_code': 10003,
     'ret_msg': 'API key is invalid.',
     'time_now': '1675073368.248223'}

123
# Place Active Order
response = client.Order.Order_new(side="Buy",symbol="BTCUSD",order_type="Limit",qty=1,price=8300,time_in_force="GoodTillCancel")
if response.ret_code == 0:
    print("Order placed successfully")
else:
    print("Order placement failed with error code:", response.ret_code)

# Get Active Order
response = client.Order.Order_getOrders(symbol="BTCUSD")
if response.ret_code == 0:
    print("Active orders:", response.result)
else:
    print("Failed to retrieve active orders with error code:", response.ret_code)

# Cancel Active Order
order_id = "123456" # Replace with the actual order_id
response = client.Order.Order_cancel(order_id=order_id)
if response.ret_code == 0:
    print("Order cancelled successfully")
else:
    print("Order cancellation failed with error code:", response.ret_code)



unseen_mails = list(imap_server.search("UNSEEN"))
imap_server.set_flags([bytes(str(mail_id), 'utf-8') for mail_id in unseen_mails], [b'\\Seen'])



search_criteria = {'UNSEEN'}
email_ids = imap_server.search(search_criteria)

# Get the first email
email_id = email_ids[0]

# Mark the email as seen
imap_server.set_flags([email_id], [b'\\Seen'])
 
 
 
 # print(client.Order.Order_cancel(symbol="BTCUSD", order_id="a0bc44c0-6ddb-4f41-913d-fa9d5299d7c2").result())
# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol="BTCUSD").result())
# Replace Active Order
# print(client.Order.Order_replace(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec", p_r_qty="3").result())
# Query Active Orders(real-time)
# print(client.Order.Order_query(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec").result())
 
 
 /home/j/py/.venv/bin/python /home/j/py/app.py
Traceback (most recent call last):
  File "/home/j/py/app.py", line 79, in <module>
    data = request.data
  File "/home/j/.local/lib/python3.10/site-packages/werkzeug/local.py", line 316, in __get__
    obj = instance._get_current_object()  # type: ignore[misc]
  File "/home/j/.local/lib/python3.10/site-packages/werkzeug/local.py", line 513, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of request context.

This typically means that you attempted to use functionality that needed
an active HTTP request. Consult the documentation on testing for
information about how to avoid this problem.

data = '{"passphrase": "xyz", "time": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'





from flask import Flask, request
import pyzmail
import json
import imapclient
import bybit
import time
import email
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/ex', methods=['POST'])
# Connect to email server
# Search for email with desired data
# search_criteria = ['SUBJECT', 'Trade Data']
# uid_list = imap_client.search(search_criteria)
# email = imap_client.fetch([uid_list[0]], ['BODY[]'])
# email_text = email[uid_list[0]][b'BODY[]'].decode()
# return email_text

def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com",993')
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')
# messages = imap_server.fetch(emails, ['BODY[]'])
    while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        # messagess = imap_server.fetch(unseen_mails, ['BODY[]'])
# Search for mails with specific keyword in the subject
# emails = imap_server.search(['SUBJECT "Alert:"'])


# Process the new emails
        for email_id, email_data in imap_server.fetch(unseen_mails, 'RFC822').items():
    # Iterate through the messages
         email_body = email_data.get_body().decode()
        # Extract the relevant information from the email
         passphrase = email_body.split("Passphrase: ")[1].split("\n")[0]
         strategy_position_size = email_body.split("Position size: ")[1].split("\n")[0]
         strategy_order_action = email_body.split("Order action: ")[1].split("\n")[0]
         strategy_order_contracts = email_body.split("Order contracts: ")[1].split("\n")[0]
         strategy_order_price = email_body.split("Order price: ")[1].split("\n")[0]
         strategy_order_id = email_body.split("Order ID: ")[1].split("\n")[0]
         strategy_market_position = email_body.split("Market position: ")[1].split("\n")[0]
         strategy_market_position_size = email_body.split("Market position size: ")[1].split("\n")[0]
         strategy_prev_market_position = email_body.split("Previous market position: ")[1].split("\n")[0]
         strategy_prev_market_position_size = email_body.split("Previous market position size: ")[1].split("\n")[0]
        # Mark the message as seen
        unseen_mails.mark_seen([email_id])
        # Sleep for a few seconds before checking for new messages again
        time.sleep(5)








from flask import Flask, request
import pyzmail
import json
import imapclient
import bybit
import time
import email
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/ex', methods=['POST'])
# Connect to email server
# Search for email with desired data
# search_criteria = ['SUBJECT', 'Trade Data']
# uid_list = imap_client.search(search_criteria)
# email = imap_client.fetch([uid_list[0]], ['BODY[]'])
# email_text = email[uid_list[0]][b'BODY[]'].decode()
# return email_text

def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com",993')
    imap_server.login('', '')
    imap_server.select_folder('INBOX')
# messages = imap_server.fetch(emails, ['BODY[]'])
    while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        # messagess = imap_server.fetch(unseen_mails, ['BODY[]'])
# Search for mails with specific keyword in the subject
# emails = imap_server.search(['SUBJECT "Alert:"'])



if json_data.get("passphrase") != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()
# Extract the other information from the email
api_key = json_data["api_key"]
secret_key = json_data["secret_key"]
strategy = json_data["strategy"]

# Initialize the Bybit client
client = bybit.BybitClient(api_key=api_key, secret_key=secret_key)

# Place the order
order_response = client.Order.Order_new(side=strategy["side"], symbol=strategy["symbol"], order_type=strategy["order_type"],
                                        qty=strategy["qty"], price=strategy["price"], time_in_force=strategy["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = client.Order.Order_query(symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")

# Process the new emails
        for email_id, email_data in unseen_mails.fetch(unseen_mails, 'RFC822').items():
    # Iterate through the messages
         email_body = unseen_mails.get_body().decode()
        # Extract the relevant information from the email
         passphrase = email_body.split("Passphrase: ")[1].split("\n")[0]
         strategy_position_size = email_body.split("Position size: ")[1].split("\n")[0]
         strategy_order_action = email_body.split("Order action: ")[1].split("\n")[0]
         strategy_order_contracts = email_body.split("Order contracts: ")[1].split("\n")[0]
         strategy_order_price = email_body.split("Order price: ")[1].split("\n")[0]
         strategy_order_id = email_body.split("Order ID: ")[1].split("\n")[0]
         strategy_market_position = email_body.split("Market position: ")[1].split("\n")[0]
         strategy_market_position_size = email_body.split("Market position size: ")[1].split("\n")[0]
         strategy_prev_market_position = email_body.split("Previous market position: ")[1].split("\n")[0]
         strategy_prev_market_position_size = email_body.split("Previous market position size: ")[1].split("\n")[0]
        # Mark the message as seen
        unseen_mails.mark_seen([email_id])
        # Sleep for a few seconds before checking for new messages again
        time.sleep(5)
    # Log out of the email server
    # # imap_server.logout()
    # Define json data
json_data = {
    "passphrase": "{{passphrase}}",
    "time": "{{timenow}}",
    "exchange": "{{exchange}}",
    "ticker": "{{ticker}}",
    "bar": {
        "time": "{{ticker}}",
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
            "close": "{{close}}",
            "volume": "{{volume}}",
        },
        "strategy": {
            "side": "side",
            "symbol": "symbol",
            "order_type": "Limit",
            "qty": "qty",
            "price": "price",
            "time_in_force": "GoodTillCancel"
        }
}
    # Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
request =json.loads(json_data)
if "passphrase" != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
# Check if the passphrase in the email matches the passphrase in the json data
# if passphrase != json_data["passphrase"]:
#   else return "Error: Incorrect passphrase."

# Extract the other information from the email
# Initialize the Bybit client
client = bybit.BybitClient(api_key='YOUR_API_KEY',
                           secret_key='YOUR_SECRET_KEY')

# Authenticate using your API key
# client.authenticate(api_key=json_data["api_key"], secret_key=json_data["secret_key"])

# Place the order
order_response = client.Order.Order_new(side=json_data["strategy"]["side"], symbol=json_data["strategy"]["symbol"], order_type=json_data["strategy"]
                                        ["order_type"], qty=json_data["strategy"]["qty"], price=json_data["strategy"]["price"], time_in_force=json_data["strategy"]["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = bybit.Order.Order_query(
    symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    # Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    return

# Extract the other information from the email
api_key = json_data["api_key"]
secret_key = json_data["secret_key"]
strategy = json_data["strategy"]

# Initialize the Bybit client
client = bybit.BybitClient(api_key=api_key, secret_key=secret_key)

# Place the order
order_response = client.Order.Order_new(side=strategy["side"], symbol=strategy["symbol"], order_type=strategy["order_type"],
                                        qty=strategy["qty"], price=strategy["price"], time_in_force=strategy["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = client.Order.Order_query(symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    
    
    json_data = {
    "passphrase": "a321!",
    "time": "2023-01-30T12:00:00Z",
    "exchange": "NYSEMkt",
    "ticker": "AAPL",
    "bar": {
        "time": "2023-01-30T12:00:00Z",
        "open": 132.5,
        "high": 135.0,
        "low": 131.0,
        "close": 132.0,
        "volume": 100000
    },
    "strategy": {
        "position_size": 10,
        "order_action": "buy",
        "order_contracts": 10,
        "order_price": 132.0,
        "order_id": "Close position order",
        "market_position": "long",
        "market_position_size": 10,
        "prev_market_position": "short"
    },
    "account": {
        "side": "buy",
        "symbol": "AAPL",
        "order_type": "Limit",
        "qty": 100,
        "price": 132.0,
        "time_in_force": "GoodTillCancel"
    }
}
    
    
    
    
    


# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
time = json_data["time"]
exchange = json_data["exchange"]
ticker = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
position_size = strategy.get("position_size", "")
order_action = strategy.get("order_action", "")
order_contracts = strategy.get("order_contracts", "")
order_price = strategy.get("order_price", "")
order_id = strategy.get("order_id", "")
market_position = strategy.get("market_position", "")
market_position_size = strategy.get("market_position_size", "")
prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
side = account.get("side", "")
symbol = account.get("symbol", "")
order_type = account.get("order_type", "")
qty = account.get("qty", "")
price = account.get("price", "")
time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Time:", time)
print("Exchange:", exchange)
print("Ticker:", ticker)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", position_size)
print("Order Action:", order_action)
print("Order Contracts:", order_contracts)
print("Order Price:", order_price)
print("Order ID:", order_id)
print("Market Position:", market_position)
print("Market Position Size:", market_position_size)
print("Prev Market Position:", prev_market_position)
print("Side:", side)
print("Symbol:", symbol)
print("Order Type:", order_type)
print("Qty:", qty)
print("Price:", price)
print("Time In Force:", time_in_force)



expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()




expected_passphrase = "a321!"
passphrase = json_data.get("passphrase", None)
if passphrase != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()
    
    
    
    
    
    
    
    
    
    
    
        while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        for email_id, email_data in imap_server.fetch(unseen_mails, 'RFC822').items():
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(r'Previous market position size: (.*)', email_body).group(1)
        imap_server.mark_seen([email_id])
        time.sleep(5)
