def execute_trade():  
    imap_server = IMAPClient('outlook.office365.com',993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')
    
    while True:
        unseen_mails = imap_server.search("UNSEEN")
        if unseen_mails:
            mail_id = list(unseen_mails)[0]
            email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(
                r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(
                r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(
                r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(
                r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(
                r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(
                r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(
                r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(
                r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(
                r'Previous market position size: (.*)', email_body).group(1)
        else:
            print("No messages found")
        
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
        time.sleep(5)
    imap_server.logout()

json_data = {
"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": { 
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
        "close": "{{close}}",
        "volume": "{{volume}}",
},
"order": {
     "side": "side",
     "symbol": "symbol",
     "type": "Limit",
     "qty": "qty",
     "price": "price",
     "time_in_force






















Traceback (most recent call last):
  File "/home/j/.local/bin/flask", line 8, in <module>
    sys.exit(main())
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 1047, in main
    cli.main()
  File "/usr/lib/python3/dist-packages/click/core.py", line 1053, in main
    rv = self.invoke(ctx)
  File "/usr/lib/python3/dist-packages/click/core.py", line 1659, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
  File "/usr/lib/python3/dist-packages/click/core.py", line 1395, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "/usr/lib/python3/dist-packages/click/core.py", line 754, in invoke
    return __callback(*args, **kwargs)
  File "/usr/lib/python3/dist-packages/click/decorators.py", line 84, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
  File "/usr/lib/python3/dist-packages/click/core.py", line 754, in invoke
    return __callback(*args, **kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 911, in run_command
    raise e from None
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 897, in run_command
    app = info.load_app()
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 308, in load_app
    app = locate_app(import_name, name)
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 218, in locate_app
    __import__(module_name)
  File "/home/j/py/app.py", line 152, in <module>
    with open("side.json") as f:
FileNotFoundError: [Errno 2] No such file or directory: 'side.json'


"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": { 
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
        "close": "{{close}}",
        "volume": "{{volume}}",
},
"order": {
"side": "side",
"symbol": "symbol",
"type": "Limit",
"qty": "qty",
"price": "price",
"time_in_force": "gtc"
},
"passphrase": "{{passphrase}}"
}














"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": {
"timestamp": "{{timestamp}}",
"open": "{{open}}",
"high": "{{high}}",
"low": "{{low}}",
"close": "{{close}}",
"volume": "{{volume}}",
},
"order": {
"side": "side",
"symbol": "symbol",
"type": "Limit",
"qty": "qty",
"price": "price",
"time_in_force": "gtc"
},
"passphrase": "{{passphrase}}"
}
## Initialize the Bybit client
client = bybit.bybit(test=False, api_key= "76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
print(client.Order.Order_getOrders(symbol="symbol").result())
# My Position
print(client.Positions.Positions_myPosition(symbol="symbol").result())
# If the order is filled, print a message


symbol_json_data = json.load(f)
symbol = symbol_json_data["symbol"]

with open("side.json") as f:
side_json_data = json.load(f)
side = side_json_data["side"]

with open("order_type.json") as f:
order_type_json_data = json.load(f)
order_type = order_type_json_data["order_type"]

with open("qty.json") as f:
qty_json_data = json.load(f)
qty = qty_json_data["qty"]

with open("price.json") as f:
price_json_data = json.load(f)
price = price_json_data["price"]

with open("time_in_force.json") as f:
time_in_force_json_data = json.load(f)
time_in_force = time_in_force_json_data["time_in_force"]
    
symbol = json_data["symbol"]
side = json_data["side"]
order_type = json_data["order_type"]
qty = json_data["qty"]
price = json_data["price"]
time_in_force = json_data["time_in_force"]



76QjbsflcrBdSZiSr
SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32p
## Initialize the Bybit client
client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
print(client.Order.Order_getOrders(symbol="symbol").result())


client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
response = client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result()

if response.ret_code == 0:
    print("Order placed successfully")
else:
    print("Order placement failed with error code:", response.ret_code)

# Get the order ID from the response
order_list_response = client.Order.Order_getOrders(symbol="symbol").result()
if order_list_response.ret_code == 0:
    order_id = order_list_response.result[0].order_id
    print("Order ID:", order_id)
else:
    print("Order info retrieval failed with error code:", order_list_response.ret_code)


client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
response = client.Order.Order_getOrders(symbol="symbol").result()
order_id = response[0]

got all these errors
({'ret_code': 10003, 'ret_msg': 'API key is invalid.', 'result': {}, 'ext_code': '', 'ext_info': '', 'time_now': '1675073367.977186', 'rate_limit_status': 0, 'rate_limit': 0, 'rate_limit_reset_ms': 0}, <bravado.requests_client.RequestsResponseAdapter object at 0x7fd50aff40d0>)
Traceback (most recent call last):
  File "/home/j/py/app.py", line 181, in <module>
    order_details = client.Order.Order_query(
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 246, in __call__
    request_params = construct_request(
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 285, in construct_request
    construct_params(operation, request, op_kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 308, in construct_params
    marshal_param(param, param_value, request)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/param.py", line 133, in marshal_param
    validate_schema_object(swagger_spec, param_spec, value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 68, in validate_schema_object
    validate_primitive(swagger_spec, schema_object_spec, value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 43, in scrubbed
    reraise(*sys.exc_info())
  File "/usr/lib/python3/dist-packages/six.py", line 719, in reraise
    raise value
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 35, in scrubbed
    return func(*args, **kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 101, in validate_primitive
    ).validate(value)
  File "/home/j/.local/lib/python3.10/site-packages/jsonschema/validators.py", line 314, in validate
    raise error
jsonschema.exceptions.ValidationError: {'ret_code': 10003, 'ret_msg': 'API key is invalid.', 'result': {}, 'ext_code': '', 'ext_info': '', 'time_now': '1675073368.248223', 'rate_limit_status': 0, 'rate_limit': 0, 'rate_limit_reset_ms': 0} is not of type 'string'

Failed validating 'type' in schema:
    {'description': 'Order ID',
     'in': 'query',
     'name': 'order_id',
     'required': False,
     'type': 'string'}

On instance:
    {'ext_code': '',
     'ext_info': '',
     'rate_limit': 0,
     'rate_limit_reset_ms': 0,
     'rate_limit_status': 0,
     'result': {},
     'ret_code': 10003,
     'ret_msg': 'API key is invalid.',
     'time_now': '1675073368.248223'}

123
# Place Active Order
response = client.Order.Order_new(side="Buy",symbol="BTCUSD",order_type="Limit",qty=1,price=8300,time_in_force="GoodTillCancel")
if response.ret_code == 0:
    print("Order placed successfully")
else:
    print("Order placement failed with error code:", response.ret_code)

# Get Active Order
response = client.Order.Order_getOrders(symbol="BTCUSD")
if response.ret_code == 0:
    print("Active orders:", response.result)
else:
    print("Failed to retrieve active orders with error code:", response.ret_code)

# Cancel Active Order
order_id = "123456" # Replace with the actual order_id
response = client.Order.Order_cancel(order_id=order_id)
if response.ret_code == 0:
    print("Order cancelled successfully")
else:
    print("Order cancellation failed with error code:", response.ret_code)



unseen_mails = list(imap_server.search("UNSEEN"))
imap_server.set_flags([bytes(str(mail_id), 'utf-8') for mail_id in unseen_mails], [b'\\Seen'])



search_criteria = {'UNSEEN'}
email_ids = imap_server.search(search_criteria)

# Get the first email
email_id = email_ids[0]

# Mark the email as seen
imap_server.set_flags([email_id], [b'\\Seen'])
 
 
 
 # print(client.Order.Order_cancel(symbol="BTCUSD", order_id="a0bc44c0-6ddb-4f41-913d-fa9d5299d7c2").result())
# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol="BTCUSD").result())
# Replace Active Order
# print(client.Order.Order_replace(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec", p_r_qty="3").result())
# Query Active Orders(real-time)
# print(client.Order.Order_query(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec").result())
 
 
 /home/j/py/.venv/bin/python /home/j/py/app.py
Traceback (most recent call last):
  File "/home/j/py/app.py", line 79, in <module>
    data = request.data
  File "/home/j/.local/lib/python3.10/site-packages/werkzeug/local.py", line 316, in __get__
    obj = instance._get_current_object()  # type: ignore[misc]
  File "/home/j/.local/lib/python3.10/site-packages/werkzeug/local.py", line 513, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of request context.

This typically means that you attempted to use functionality that needed
an active HTTP request. Consult the documentation on testing for
information about how to avoid this problem.

data = '{"passphrase": "xyz", "time": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'





from flask import Flask, request
import pyzmail
import json
import imapclient
import bybit
import time
import email
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/ex', methods=['POST'])
# Connect to email server
# Search for email with desired data
# search_criteria = ['SUBJECT', 'Trade Data']
# uid_list = imap_client.search(search_criteria)
# email = imap_client.fetch([uid_list[0]], ['BODY[]'])
# email_text = email[uid_list[0]][b'BODY[]'].decode()
# return email_text

def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com",993')
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')
# messages = imap_server.fetch(emails, ['BODY[]'])
    while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        # messagess = imap_server.fetch(unseen_mails, ['BODY[]'])
# Search for mails with specific keyword in the subject
# emails = imap_server.search(['SUBJECT "Alert:"'])


# Process the new emails
        for email_id, email_data in imap_server.fetch(unseen_mails, 'RFC822').items():
    # Iterate through the messages
         email_body = email_data.get_body().decode()
        # Extract the relevant information from the email
         passphrase = email_body.split("Passphrase: ")[1].split("\n")[0]
         strategy_position_size = email_body.split("Position size: ")[1].split("\n")[0]
         strategy_order_action = email_body.split("Order action: ")[1].split("\n")[0]
         strategy_order_contracts = email_body.split("Order contracts: ")[1].split("\n")[0]
         strategy_order_price = email_body.split("Order price: ")[1].split("\n")[0]
         strategy_order_id = email_body.split("Order ID: ")[1].split("\n")[0]
         strategy_market_position = email_body.split("Market position: ")[1].split("\n")[0]
         strategy_market_position_size = email_body.split("Market position size: ")[1].split("\n")[0]
         strategy_prev_market_position = email_body.split("Previous market position: ")[1].split("\n")[0]
         strategy_prev_market_position_size = email_body.split("Previous market position size: ")[1].split("\n")[0]
        # Mark the message as seen
        unseen_mails.mark_seen([email_id])
        # Sleep for a few seconds before checking for new messages again
        time.sleep(5)








from flask import Flask, request
import pyzmail
import json
import imapclient
import bybit
import time
import email
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/ex', methods=['POST'])
# Connect to email server
# Search for email with desired data
# search_criteria = ['SUBJECT', 'Trade Data']
# uid_list = imap_client.search(search_criteria)
# email = imap_client.fetch([uid_list[0]], ['BODY[]'])
# email_text = email[uid_list[0]][b'BODY[]'].decode()
# return email_text

def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com",993')
    imap_server.login('', '')
    imap_server.select_folder('INBOX')
# messages = imap_server.fetch(emails, ['BODY[]'])
    while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        # messagess = imap_server.fetch(unseen_mails, ['BODY[]'])
# Search for mails with specific keyword in the subject
# emails = imap_server.search(['SUBJECT "Alert:"'])



if json_data.get("passphrase") != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()
# Extract the other information from the email
api_key = json_data["api_key"]
secret_key = json_data["secret_key"]
strategy = json_data["strategy"]

# Initialize the Bybit client
client = bybit.BybitClient(api_key=api_key, secret_key=secret_key)

# Place the order
order_response = client.Order.Order_new(side=strategy["side"], symbol=strategy["symbol"], order_type=strategy["order_type"],
                                        qty=strategy["qty"], price=strategy["price"], time_in_force=strategy["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = client.Order.Order_query(symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")

# Process the new emails
        for email_id, email_data in unseen_mails.fetch(unseen_mails, 'RFC822').items():
    # Iterate through the messages
         email_body = unseen_mails.get_body().decode()
        # Extract the relevant information from the email
         passphrase = email_body.split("Passphrase: ")[1].split("\n")[0]
         strategy_position_size = email_body.split("Position size: ")[1].split("\n")[0]
         strategy_order_action = email_body.split("Order action: ")[1].split("\n")[0]
         strategy_order_contracts = email_body.split("Order contracts: ")[1].split("\n")[0]
         strategy_order_price = email_body.split("Order price: ")[1].split("\n")[0]
         strategy_order_id = email_body.split("Order ID: ")[1].split("\n")[0]
         strategy_market_position = email_body.split("Market position: ")[1].split("\n")[0]
         strategy_market_position_size = email_body.split("Market position size: ")[1].split("\n")[0]
         strategy_prev_market_position = email_body.split("Previous market position: ")[1].split("\n")[0]
         strategy_prev_market_position_size = email_body.split("Previous market position size: ")[1].split("\n")[0]
        # Mark the message as seen
        unseen_mails.mark_seen([email_id])
        # Sleep for a few seconds before checking for new messages again
        time.sleep(5)
    # Log out of the email server
    # # imap_server.logout()
    # Define json data
json_data = {
    "passphrase": "{{passphrase}}",
    "time": "{{timenow}}",
    "exchange": "{{exchange}}",
    "ticker": "{{ticker}}",
    "bar": {
        "time": "{{ticker}}",
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
            "close": "{{close}}",
            "volume": "{{volume}}",
        },
        "strategy": {
            "side": "side",
            "symbol": "symbol",
            "order_type": "Limit",
            "qty": "qty",
            "price": "price",
            "time_in_force": "GoodTillCancel"
        }
}
    # Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
request =json.loads(json_data)
if "passphrase" != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
# Check if the passphrase in the email matches the passphrase in the json data
# if passphrase != json_data["passphrase"]:
#   else return "Error: Incorrect passphrase."

# Extract the other information from the email
# Initialize the Bybit client
client = bybit.BybitClient(api_key='YOUR_API_KEY',
                           secret_key='YOUR_SECRET_KEY')

# Authenticate using your API key
# client.authenticate(api_key=json_data["api_key"], secret_key=json_data["secret_key"])

# Place the order
order_response = client.Order.Order_new(side=json_data["strategy"]["side"], symbol=json_data["strategy"]["symbol"], order_type=json_data["strategy"]
                                        ["order_type"], qty=json_data["strategy"]["qty"], price=json_data["strategy"]["price"], time_in_force=json_data["strategy"]["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = bybit.Order.Order_query(
    symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    # Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    return

# Extract the other information from the email
api_key = json_data["api_key"]
secret_key = json_data["secret_key"]
strategy = json_data["strategy"]

# Initialize the Bybit client
client = bybit.BybitClient(api_key=api_key, secret_key=secret_key)

# Place the order
order_response = client.Order.Order_new(side=strategy["side"], symbol=strategy["symbol"], order_type=strategy["order_type"],
                                        qty=strategy["qty"], price=strategy["price"], time_in_force=strategy["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = client.Order.Order_query(symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    
    
    json_data = {
    "passphrase": "a321!",
    "time": "2023-01-30T12:00:00Z",
    "exchange": "NYSEMkt",
    "ticker": "AAPL",
    "bar": {
        "time": "2023-01-30T12:00:00Z",
        "open": 132.5,
        "high": 135.0,
        "low": 131.0,
        "close": 132.0,
        "volume": 100000
    },
    "strategy": {
        "position_size": 10,
        "order_action": "buy",
        "order_contracts": 10,
        "order_price": 132.0,
        "order_id": "Close position order",
        "market_position": "long",
        "market_position_size": 10,
        "prev_market_position": "short"
    },
    "account": {
        "side": "buy",
        "symbol": "AAPL",
        "order_type": "Limit",
        "qty": 100,
        "price": 132.0,
        "time_in_force": "GoodTillCancel"
    }
}
    
    
    
    
    


# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
time = json_data["time"]
exchange = json_data["exchange"]
ticker = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
position_size = strategy.get("position_size", "")
order_action = strategy.get("order_action", "")
order_contracts = strategy.get("order_contracts", "")
order_price = strategy.get("order_price", "")
order_id = strategy.get("order_id", "")
market_position = strategy.get("market_position", "")
market_position_size = strategy.get("market_position_size", "")
prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
side = account.get("side", "")
symbol = account.get("symbol", "")
order_type = account.get("order_type", "")
qty = account.get("qty", "")
price = account.get("price", "")
time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Time:", time)
print("Exchange:", exchange)
print("Ticker:", ticker)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", position_size)
print("Order Action:", order_action)
print("Order Contracts:", order_contracts)
print("Order Price:", order_price)
print("Order ID:", order_id)
print("Market Position:", market_position)
print("Market Position Size:", market_position_size)
print("Prev Market Position:", prev_market_position)
print("Side:", side)
print("Symbol:", symbol)
print("Order Type:", order_type)
print("Qty:", qty)
print("Price:", price)
print("Time In Force:", time_in_force)



expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()




expected_passphrase = "a321!"
passphrase = json_data.get("passphrase", None)
if passphrase != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()
    
    
    
    
    
    
    
    
    
    
    
        while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        for email_id, email_data in imap_server.fetch(unseen_mails, 'RFC822').items():
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(r'Previous market position size: (.*)', email_body).group(1)
        imap_server.mark_seen([email_id])
        time.sleep(5)
