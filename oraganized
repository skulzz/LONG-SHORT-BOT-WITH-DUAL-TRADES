from flask import Flask, request
import pyzmail
import json
import imapclient
import bybit
import time
import email
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/ex', methods=['POST'])
# Connect to email server
# Search for email with desired data
# search_criteria = ['SUBJECT', 'Trade Data']
# uid_list = imap_client.search(search_criteria)
# email = imap_client.fetch([uid_list[0]], ['BODY[]'])
# email_text = email[uid_list[0]][b'BODY[]'].decode()
# return email_text

def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com",993')
    imap_server.login('', '')
    imap_server.select_folder('INBOX')
# messages = imap_server.fetch(emails, ['BODY[]'])
    while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        # messagess = imap_server.fetch(unseen_mails, ['BODY[]'])
# Search for mails with specific keyword in the subject
# emails = imap_server.search(['SUBJECT "Alert:"'])


# Extract the other information from the email
api_key = json_data["api_key"]
secret_key = json_data["secret_key"]
strategy = json_data["strategy"]

# Initialize the Bybit client
client = bybit.BybitClient(api_key=api_key, secret_key=secret_key)

# Place the order
order_response = client.Order.Order_new(side=strategy["side"], symbol=strategy["symbol"], order_type=strategy["order_type"],
                                        qty=strategy["qty"], price=strategy["price"], time_in_force=strategy["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = client.Order.Order_query(symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")

# Process the new emails
        for email_id, email_data in unseen_mails.fetch(unseen_mails, 'RFC822').items():
    # Iterate through the messages
         email_body = unseen_mails.get_body().decode()
        # Extract the relevant information from the email
         passphrase = email_body.split("Passphrase: ")[1].split("\n")[0]
         strategy_position_size = email_body.split("Position size: ")[1].split("\n")[0]
         strategy_order_action = email_body.split("Order action: ")[1].split("\n")[0]
         strategy_order_contracts = email_body.split("Order contracts: ")[1].split("\n")[0]
         strategy_order_price = email_body.split("Order price: ")[1].split("\n")[0]
         strategy_order_id = email_body.split("Order ID: ")[1].split("\n")[0]
         strategy_market_position = email_body.split("Market position: ")[1].split("\n")[0]
         strategy_market_position_size = email_body.split("Market position size: ")[1].split("\n")[0]
         strategy_prev_market_position = email_body.split("Previous market position: ")[1].split("\n")[0]
         strategy_prev_market_position_size = email_body.split("Previous market position size: ")[1].split("\n")[0]
        # Mark the message as seen
        unseen_mails.mark_seen([email_id])
        # Sleep for a few seconds before checking for new messages again
        time.sleep(5)
    # Log out of the email server
    # # imap_server.logout()
    # Define json data
json_data = {
    "passphrase": "{{passphrase}}",
    "time": "{{timenow}}",
    "exchange": "{{exchange}}",
    "ticker": "{{ticker}}",
    "bar": {
        "time": "{{ticker}}",
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
            "close": "{{close}}",
            "volume": "{{volume}}",
        },
        "strategy": {
            "side": "side",
            "symbol": "symbol",
            "order_type": "Limit",
            "qty": "qty",
            "price": "price",
            "time_in_force": "GoodTillCancel"
        }
}
    # Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
request =json.loads(json_data)
if "passphrase" != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
# Check if the passphrase in the email matches the passphrase in the json data
# if passphrase != json_data["passphrase"]:
#   else return "Error: Incorrect passphrase."

# Extract the other information from the email
# Initialize the Bybit client
client = bybit.BybitClient(api_key='YOUR_API_KEY',
                           secret_key='YOUR_SECRET_KEY')

# Authenticate using your API key
# client.authenticate(api_key=json_data["api_key"], secret_key=json_data["secret_key"])

# Place the order
order_response = client.Order.Order_new(side=json_data["strategy"]["side"], symbol=json_data["strategy"]["symbol"], order_type=json_data["strategy"]
                                        ["order_type"], qty=json_data["strategy"]["qty"], price=json_data["strategy"]["price"], time_in_force=json_data["strategy"]["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = bybit.Order.Order_query(
    symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    # Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    return

# Extract the other information from the email
api_key = json_data["api_key"]
secret_key = json_data["secret_key"]
strategy = json_data["strategy"]

# Initialize the Bybit client
client = bybit.BybitClient(api_key=api_key, secret_key=secret_key)

# Place the order
order_response = client.Order.Order_new(side=strategy["side"], symbol=strategy["symbol"], order_type=strategy["order_type"],
                                        qty=strategy["qty"], price=strategy["price"], time_in_force=strategy["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = client.Order.Order_query(symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    
    
    json_data = {
    "passphrase": "a321!",
    "time": "2023-01-30T12:00:00Z",
    "exchange": "NYSEMkt",
    "ticker": "AAPL",
    "bar": {
        "time": "2023-01-30T12:00:00Z",
        "open": 132.5,
        "high": 135.0,
        "low": 131.0,
        "close": 132.0,
        "volume": 100000
    },
    "strategy": {
        "position_size": 10,
        "order_action": "buy",
        "order_contracts": 10,
        "order_price": 132.0,
        "order_id": "Close position order",
        "market_position": "long",
        "market_position_size": 10,
        "prev_market_position": "short"
    },
    "account": {
        "side": "buy",
        "symbol": "AAPL",
        "order_type": "Limit",
        "qty": 100,
        "price": 132.0,
        "time_in_force": "GoodTillCancel"
    }
}
    
    
    
    
    








