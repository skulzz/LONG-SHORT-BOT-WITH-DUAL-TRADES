def get_parsed_data_from_email_body(email_body):
    parsed_data = {}
    account_symbol_match = re.search(
        r"account_symbol.*?:.*?([\w\d]+)", email_body)
    if account_symbol_match:
        parsed_data["account_symbol"] = account_symbol_match.group(1)
    account_side_match = re.search(r"account_side.*?:.*?([\w\d]+)", email_body)
    if account_side_match:
        parsed_data["account_side"] = account_side_match.group(1)
    account_volume_match = re.search(r"account_volume.*?:.*?(\d+)", email_body)
    if account_volume_match:
        parsed_data["account_volume"] = int(account_volume_match.group(1))
    order_price_match = re.search(r"order_price.*?:.*?(\d+)", email_body)
    if order_price_match:
        parsed_data["order_price"] = int(order_price_match.group(1))
    return parsed_data
    
    if parsed_data:
    print(client.Order.Order_new(
                symbol=account_symbol, qty=account_volume, side=account_side, type='LIMIT', timeInForce='GTC', limitPrice=order_price).result())
        else:
        print("Cannot place order, missing parameters.")
            print(client.Order.Order_query(symbol='account_symbol').result())
        print(client.Positions.Positions_myPosition(
            symbol=account_symbol).result())
    return "Success"








import imaplib
import ssl
import certifi
import bybit
from flask import Flask, request, jsonify

app = Flask(__name__)
app.debug = True

servername = "imap.gmx.com"
usernm = "skullze@gmx.com"
passwd = "Mando321!"
ssl_context = ssl.create_default_context(cafile=certifi.where())
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

@app.route("/emaill", methods=['POST', 'GET'])
def email_handler():
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    for email_id in mail_ids:
        email_info = conn.fetch(email_id, "(RFC822)")
        email_body = email_info[0][1].decode("utf-8")
        parsed_data = get_parsed_data_from_email_body(email_body)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")

def get_parsed_data_from_email_body(email_body):
    parsed_data = {}
    account_symbol_match = re.search(
        r"account_symbol.*?:.*?([\w\d]+)", email_body)
    if account_symbol_match:
        parsed_data["account_symbol"] = account_symbol_match.group(1)
    account_side_match = re.search(r"account_side.*?:.*?([\w\d]+)", email_body)
    if account_side_match:
        parsed_data["account_side"] = account_side_match.group(1)
    account_volume_match = re.search(r"account_volume.*?:.*?(\d+)", email_body)
    if account_volume_match:
        parsed_data["account_volume"] = int(account_volume_match.group(1))
    order_price_match = re.search(r"order_price.*?:.*?(\d+)", email_body)
    if order_price_match:
        parsed_data["order_price"] = int(order_price_match















import re
import imaplib
import ssl
import certifi
import bybit
from flask import Flask, request, jsonify

app = Flask(__name__)
app.debug = True

@app.route("/emaill", methods=['POST', 'GET'])
def email_handler():
    servername = "imap.gmx.com"
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    for email_id in mail_ids:
        email_info = conn.fetch(email_id, "(RFC822)")
        email_body = email_info[0][1].decode("utf-8")
        parsed_data = get_parsed_data_from_email_body(email_body)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")

def get_parsed_data_from_email_body(email_body):
    parsed_data = {}
    account_symbol_match = re.search(
        r"account_symbol.*?:.*?([\w\d]+)", email_body)
    if account_symbol_match:
        parsed_data["account_symbol"] = account_symbol_match.group(1)
    account_side_match = re.search(r"account_side.*?:.*?([\w\d]+)", email_body)
    if account_side_match:
        parsed_data["account_side"] = account_side_match.group(1)
    account_volume_match = re.search(r"account_volume.*?:.*?(\d+)", email_body)
    if account_volume_match:
        parsed_data["account_volume"] = int(account_volume_match.group(1))
    order_price_match = re.search(r"order_price.*?:.*?(\d+)", email_body)
    if order_price_match:
        parsed_data["order_price"] = int(order_price_match.group(1))
    return parsed_data

@app.route("/email", methods=['POST', 'GET'])
def email():
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    for email_id in mail_ids:
        email_info = conn.fetch(email_id, "(RFC822)")
        email_body = email_info[0][1].decode("utf-8")
        parsed_data = get_data_from_email_body(email_body)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")
        if account_symbol and account_volume and account_side and order_price:
            print(client.Order.Order_new(
                symbol=account_symbol, qty=account_volume, side=account_side, type='LIMIT', timeInForce='GTC', limitPrice=order_price).result())
        else:
            print("Cannot place order, missing parameters.")
            print(client.Order.Order_query(symbol='account_symbol').result())
        print(client.Positions.Positions_myPosition(
            symbol=account_symbol).result())
    return "Success"

if __name__ == "__main__":
    app.run(port=5003)





app = Flask(__name__)
app.debug = True


@app.route("/email", methods=['POST', 'GET'])
def email_handler():
    servername = "imap.gmx.com"
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    for email_id in mail_ids:
        email_info = conn.fetch(email_id, "(RFC822)")
        email_body = email_info[0][1].decode("utf-8")
        parsed_data = get_parsed_data_from_email_body(email_body)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")
        if account_symbol and account_volume and account_side and order_price:
            # Place the order
            print(client.Order.Order_query(symbol='account_symbol').result())
            print(client.Positions.Positions_myPosition(
                symbol=account_symbol).result())
        else:
            print("Cannot place order. Parsed data: ", parsed_data)


def get_parsed_data_from_email_body(email_body):
    parsed_data = {}
    account_symbol_match = re.search(
        r"account_symbol.*?:.*?([\w\d]+)", email_body)
    if account_symbol_match:
        parsed_data["account_symbol"] = account_symbol_match.group(1)
    account_side_match = re.search(r"account_side.*?:.*?([\w\d]+)", email_body)
    if account_side_match:
        parsed_data["account_side"] = account_side_match.group(1)
    account_volume_match = re.search(r"account_volume.*?:.*?(\d+)", email_body)
    if account_volume_match:
        parsed_data["account_volume"] = int(account_volume_match.group(1))
    order_price_match = re.search(r"order_price.*?:.*?(\d+)", email_body)
    if order_price_match:
        parsed_data["order_price"] = int(order_price_match.group(1))
    return parsed_data

@app.route("/email", methods=['POST', 'GET'])
def email():
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    for email_id in mail_ids:
        email_info = conn.fetch(email_id, "(RFC822)")
        email_body = email_info[0][1].decode("utf-8")
        parsed_data = get_data_from_email_body(email_body)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")
        if account_symbol and account_volume and account_side and order_price:
            print(client.Order.Order_new(
                symbol=account_symbol, qty=account_volume, side=account_side, type='LIMIT', timeInForce='GTC', limitPrice=order_price).result())
        else:
            print("Cannot place order, missing parameters.")
            print(client.Order.Order_query(symbol='account_symbol').result())
        print(client.Positions.Positions_myPosition(
            symbol=account_symbol).result())
    return "Success"

if __name__ == "__main__":
    app.run(port=5003)



















app = Flask(__name__)
app.debug = True


@app.route("/email", methods=['POST', 'GET'])
def get_data_from_email_body(email_body):
    servername = "imap.gmx.com"
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    _, email_info = conn.fetch(mail_ids, "(RFC822)")
    email_body = email_info[0][1].decode("utf-8")


def get_data_from_email_body(email_body):
    parsed_data = {}
    account_symbol_match = re.search(
        r"account_symbol.*?:.*?([\w\d]+)", email_body)
    if account_symbol_match:
        parsed_data["account_symbol"] = account_symbol_match.group(1)
    account_side_match = re.search(r"account_side.*?:.*?([\w\d]+)", email_body)
    if account_side_match:
        parsed_data["account_side"] = account_side_match.group(1)
    account_volume_match = re.search(r"account_volume.*?:.*?(\d+)", email_body)
    if account_volume_match:
        parsed_data["account_volume"] = int(account_volume_match.group(1))
    order_price_match = re.search(r"order_price.*?:.*?(\d+)", email_body)
    if order_price_match:
        parsed_data["order_price"] = int(order_price_match.group(1))
        return parsed_data

    email_info = conn.fetch(email_id, "(RFC822)")
    email_body = email_info[0][1].decode("utf-8")
    parsed_data = get_data_from_email_body(email_body)
    account_symbol = parsed_data.get("account_symbol")
    account_volume = parsed_data.get("account_volume")
    account_side = parsed_data.get("account_side")
    order_price = parsed_data.get("order_price")
    else:
        print("Cannot place order 'parsed_data' ")
        print(client.Order.Order_query(symbol='account_symbol').result())
    print(client.Positions.Positions_myPosition(
        symbol=account_symbol).result())


app.run(port=5003)









def get_data_from_email_body(email_body):
    parsed_data = {}
    account_symbol_match = re.search(r"account_symbol.*?:.*?([\w\d]+)", email_body)
    if account_symbol_match:
        parsed_data["account_symbol"] = account_symbol_match.group(1)
    account_side_match = re.search(r"account_side.*?:.*?([\w\d]+)", email_body)
    if account_side_match:
        parsed_data["account_side"] = account_side_match.group(1)
    account_volume_match = re.search(r"account_volume.*?:.*?(\d+)", email_body)
    if account_volume_match:
        parsed_data["account_volume"] = int(account_volume_match.group(1))
    order_price_match = re.search(r"order_price.*?:.*?(\d+)", email_body)
    if order_price_match:
        parsed_data["order_price"] = int(order_price_match.group(1))
    return parsed_data

for email_id in email_ids:
    _, email_info = conn.fetch(email_id, "(RFC822)")
    email_body = email_info[0][1].decode("utf-8")
    parsed_data = get_data_from_email_body(email_body)
    account_symbol = parsed_data.get("account_symbol")
    account_volume = parsed_data.get("account_volume")
    account_side = parsed_data.get("account_side")
    order_price = parsed_data.get("order_price")
    if account_side and account_symbol and account_volume:
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
            qty=account_volume, price=order_price, time_in_force="gtc").result())
    else:
        print("Cannot place order 'parsed_data' ")
        print(client.Order.Order_query(symbol='account_symbol').result())
    print(client.Positions.Positions_myPosition(
        symbol=account_symbol).result())




















ypeError: get_data_from_email_body() missing 1 required positional argument: 'email_body'
Traceback (most recent call last)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2548, in __call__

    return self.wsgi_app(environ, start_response)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2528, in wsgi_app

    response = self.handle_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app

    response = self.full_dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request

    rv = self.handle_user_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request

    rv = self.dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request

    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)

    TypeError: get_data_from_email_body() missing 1 required positional argument: 'email_body'



import re
import imaplib
import ssl
import certifi
import bybit
from flask import Flask, request, jsonify 

app = Flask(__name__)
app.debug = True
@app.route("/email", methods=['POST', 'GET'])
def get_data_from_email_body(email_body):
 servername = "imap.gmx.com"
 usernm = "skullze@gmx.com"
 passwd = "Mando321!"
 ssl_context = ssl.create_default_context(cafile=certifi.where())
 ssl_context.check_hostname = False
 ssl_context.verify_mode = ssl.CERT_NONE
 conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
 conn.login(usernm, passwd)
 conn.select('INBOX', readonly=True)
 typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
 mail_ids = data[0].split()
 _, email_info = conn.fetch(mail_ids, "(RFC822)")
 email_body = email_info[0][1].decode("utf-8")
 parsed_data = get_data_from_email_body(email_body)
 account_symbol = parsed_data.get("account_symbol")
 account_volume = parsed_data.get("account_volume")
 account_side = parsed_data.get("account_side")
 order_price = parsed_data.get("order_price")
 parsed_data = {}
 account_symbol_match = re.search(r"account_symbol.*?:.*?([\w\d]+)", email_body)
 if account_symbol_match:
  parsed_data["account_symbol"] = account_symbol_match.group(1)
  account_side_match = re.search(r"account_side.*?:.*?([\w\d]+)", email_body)
 if account_side_match:
    parsed_data["account_side"] = account_side_match.group(1)
    account_volume_match = re.search(r"account_volume.*?:.*?(\d+)", email_body)
    if account_volume_match:
        parsed_data["account_volume"] = int(account_volume_match.group(1))
    order_price_match = re.search(r"order_price.*?:.*?(\d+)", email_body)
    if order_price_match:
        parsed_data["order_price"] = int(order_price_match.group(1))
    return parsed_data

 if account_side and account_symbol and account_volume:
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
app.run(port=5003)










import re
import imaplib
import ssl
import certifi

def get_data_from_email_body(email_body):
    parsed_data = {}
    account_symbol_match = re.search(r"account_symbol.*?:.*?([\w\d]+)", email_body)
    if account_symbol_match:
        parsed_data["account_symbol"] = account_symbol_match.group(1)
    account_side_match = re.search(r"account_side.*?:.*?([\w\d]+)", email_body)
    if account_side_match:
        parsed_data["account_side"] = account_side_match.group(1)
    account_volume_match = re.search(r"account_volume.*?:.*?(\d+)", email_body)
    if account_volume_match:
        parsed_data["account_volume"] = int(account_volume_match.group(1))
    order_price_match = re.search(r"order_price.*?:.*?(\d+)", email_body)
    if order_price_match:
        parsed_data["order_price"] = int(order_price_match.group(1))
    return parsed_data

usernm = "skullze@gmx.com"
passwd = "Mando321!"
ssl_context = ssl.create_default_context(cafile=certifi.where())
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE
conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
conn.login(usernm, passwd)
conn.select('INBOX', readonly=True)
typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
mail_ids = data[0].split()
valid_mail_ids = [mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
if not valid_mail_ids:
    print("No unread email with subject 'alert:'")
else:
    for email_id in valid_mail_ids:
        _, email_info = conn.fetch(email_id, "(RFC822)")
        email_body = email_info[0][1].decode("utf-8")
        parsed_data = get_data_from_email_body(email_body)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")
        if account_side and account_symbol and account_volume:
            client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
            result = client.





















import imaplib
import json
from flask import Flask, request, jsonify
import bybit

app = Flask(__name__)
app.debug = True

def parse_json_data(json_data):
    parsed_data = {}
    data = json_data.get("data")
    if data:
        if "order_price" in json_data:
            parsed_data["order_price"] = json_data["order_price"]
        if "account_symbol" in json_data:
            parsed_data["account_symbol"] = json_data["account_symbol"]
        if "account_side" in json_data:
            parsed_data["account_side"] = json_data["account_side"]
        if "account_volume" in json_data:
            parsed_data["account_volume"] = json_data["account_volume"]
    return parsed_data

def get_json_data(email_body):
    try:
        json_data = json.loads(email_body)
    except json.decoder.JSONDecodeError as e:
        print("Error parsing json data: " + str(e))
        json_data = None
    return json_data

@app.route("/email", methods=['POST', 'GET'])
def process_email():
    email_body = request.get_data()
    json_data = get_json_data(email_body)
    if json_data:
        parsed_data = parse_json_data(json_data)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")
        if account_side and account_symbol and account_volume:
            client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                    api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
            result = client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
            qty=account_volume, price=order_price, time_in_force="gtc").result()
            print(result)
        else:
            print("Cannot place order, missing information in 'parsed_data'")
    else:
        print("Cannot process email, missing or invalid JSON data")
    return jsonify(parsed_data)

if __name__ == '__main__':
    conn = imaplib.IMAP4_SSL("imap.gmx.com")
    conn.login("skullze@gmx.com", "Mando321!")
    conn.select("inbox")

    _, email_data = conn.search(None, "UNSEEN")
    email_ids = email_data[0].split()

    for email_id in email_ids:
     _, email_info = conn.fetch(email_id, "(RFC822)")
    email_body = email_info[0][1].decode("utf-8")
    json_data = get_json_data(email_body)
    if json_data:
        parsed_data = parse_json_data(json_data)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")











app = Flask(__name__)
app.debug = True
@app.route("/email", methods=['POST', 'GET'])
def get_json_data():
 email_body = request.get_data()
 try:
  json_data = json.loads(email_body)
 except json.decoder.JSONDecodeError as e:
    print("Error parsing json data:" + str(e))
    json_data = None
 return jsonify(json_data)

def parse_json_data(json_data):
    # parse json data to get required information
    parsed_data = {}
    data = json_data.get("data")
    if data:
        if "order_price" in json_data:
            parsed_data["order_price"] = json_data["order_price"]
        if "account_symbol" in json_data:
            parsed_data["account_symbol"] = json_data["account_symbol"]
        if "account_side" in json_data:
            parsed_data["account_side"] = json_data["account_side"]
        if "account_volume" in json_data:
            parsed_data["account_volume"] = json_data["account_volume"]
    return parsed_data

conn = imaplib.IMAP4_SSL("imap.gmx.com")
conn.login("skullze@gmx.com", "Mando321!")
conn.select("inbox")

_, email_data = conn.search(None, "UNSEEN")
email_ids = email_data[0].split()

for email_id in email_ids:
    _, email_info = conn.fetch(email_id, "(RFC822)")
    email_body = email_info[0][1].decode("utf-8")
    json_data = get_json_data(email_body)
    if json_data:
        parsed_data = parse_json_data(json_data)
        account_symbol = parsed_data.get("account_symbol")
        account_volume = parsed_data.get("account_volume")
        account_side = parsed_data.get("account_side")
        order_price = parsed_data.get("order_price")
        if account_side and account_symbol and account_volume:
            client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                    api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
            print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
        qty=account_volume, price=order_price, time_in_force="gtc").result())
        else:
            print("Cannot place order 'parsed_data' ")
  
            print(client.Order.Order_query(symbol='account_symbol').result())
# My Position
            print(client.Positions.Positions_myPosition(
            symbol=account_symbol).result())

if __name__ == '__main__':

 app.run(port=5003)







app = Flask(__name__)

@app.route("/email", methods=['POST'])
def parse_json_data():
    if request.content_type != 'application/json':
        return "Error: Invalid Content-Type. Expected 'application/json'"

    email_body = request.get_json()
    try:
        data = json.loads(email_body)
        account_symbol = data.get("account_symbol")
        account_side = data.get("account_side")
        account_volume = data.get("account_volume")
        order_price = data.get("order_price")

        response = {}
        response['account_symbol'] = account_symbol
        response['account_side'] = account_side
        response['account_volume'] = account_volume
        response['order_price'] = order_price

        return json.dumps(response)
    except json.JSONDecodeError as error:
        print("Error: Unable to parse JSON data.")
        print(error)
        return "Error: Unable to parse JSON data."

def getMsgs(servername="imap.gmx.com"):
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')

    json_data = get_json_data(email_body)
    if json_data:
        parsed_data = parse_json_data()
        conn.logout()
        return parsed_data
    else:
        conn.logout()
        return None

def get_json_data(email_body):
    pattern = re.compile(r'{.*}')
    match = pattern.search(email_body)

    if match:
        # Extract the JSON data and parse it
        json_data = match.group()
        return json_data
    else:
        # Return None if no JSON data was found
        return None

client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                     api_secret="SGAAHPUfQnTm1d

























app = Flask(__name__)

@app.route("/email", methods=['POST'])
def parse_json_data():
    if request.content_type != 'application/json':
        return "Error: Invalid Content-Type. Expected 'application/json'"

    email_body = request.get_json()
    try:
        data = json.loads(email_body)
        account_symbol = data.get("account_symbol")
        account_side = data.get("account_side")
        account_volume = data.get("account_volume")
        order_price = data.get("order_price")

        response = {}
        response['account_symbol'] = account_symbol
        response['account_side'] = account_side
        response['account_volume'] = account_volume
        response['order_price'] = order_price

        return json.dumps(response)
    except json.JSONDecodeError as error:
        print("Error: Unable to parse JSON data.")
        print(error)
        return "Error: Unable to parse JSON data."

def getMsgs(servername="imap.gmx.com"):
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    json_data = get_json_data(email_body)
    if json_data:
        parsed_data = parse_json_data(json_data)
        conn.logout()
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                          api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

        if account_side and account_symbol and account_volume:
            print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
                  qty=account_volume, price=order_price, time_in_force="gtc").result())
        else:
            print("Cannot place order")
        return parsed_data
        
        
        
        
        





import imaplib
import re
import ssl
import certifi
import bybit
import json
from flask import Flask, request

app = Flask(__name__)

@app.route("/email", methods=['POST'])
def parse_json_data():
    if request.content_type != 'application/json':
        return "Error: Invalid Content-Type. Expected 'application/json'"

    email_body = request.get_json()
    try:
        data = json.loads(email_body)
        account_symbol = data.get("account_symbol")
        account_side = data.get("account_side")
        account_volume = data.get("account_volume")
        order_price = data.get("order_price")

        response = {}
        response['account_symbol'] = account_symbol
        response['account_side'] = account_side
        response['account_volume'] = account_volume
        response['order_price'] = order_price

        return json.dumps(response)
    except json.JSONDecodeError as error:
        print("Error: Unable to parse JSON data.")
        print(error)
        return "Error: Unable to parse JSON data."

def getMsgs(servername="imap.gmx.com"):
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    json_data = get_json_data(email_body)
    if json_data:
        parsed_data = parse_json_data()
        conn.logout()
        return parsed_data
    else:
        conn.logout()
        return None

def get_json_data(email_body):
    pattern = re.compile(r'{.*}')
    match = pattern.search(email_body)

    if match:
        # Extract the JSON data and parse it
        json_data = match.group()
        return json_data
    else:
        # Return None if no JSON data was found
        return None













 
 
 
 /home/j/py/.venv/bin/python /home/j/py/app.py
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/connection.py", line 158, in _new_conn
    conn = connection.create_connection(
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/util/connection.py", line 80, in create_connection
    raise err
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/util/connection.py", line 70, in create_connection
    sock.connect(sa)
ConnectionRefusedError: [Errno 111] Connection refused

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/connectionpool.py", line 597, in urlopen
    httplib_response = self._make_request(conn, method, url,
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/connectionpool.py", line 354, in _make_request
    conn.request(method, url, **httplib_request_kw)
  File "/usr/lib/python3.10/http/client.py", line 1282, in request
    self._send_request(method, url, body, headers, encode_chunked)
  File "/usr/lib/python3.10/http/client.py", line 1328, in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
  File "/usr/lib/python3.10/http/client.py", line 1277, in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
  File "/usr/lib/python3.10/http/client.py", line 1037, in _send_output
    self.send(msg)
  File "/usr/lib/python3.10/http/client.py", line 975, in send
    self.connect()
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/connection.py", line 181, in connect
    conn = self._new_conn()
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/connection.py", line 167, in _new_conn
    raise NewConnectionError(
urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x7ff345cc3070>: Failed to establish a new connection: [Errno 111] Connection refused

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/lib/python3/dist-packages/requests/adapters.py", line 439, in send
    resp = conn.urlopen(
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/connectionpool.py", line 637, in urlopen
    retries = retries.increment(method, url, error=e, _pool=self,
  File "/home/j/.local/lib/python3.10/site-packages/urllib3/util/retry.py", line 399, in increment
    raise MaxRetryError(_pool, url, error or ResponseError(cause))
urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=5001): Max retries exceeded with url: /email (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7ff345cc3070>: Failed to establish a new connection: [Errno 111] Connection refused'))

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/j/py/app.py", line 80, in <module>
    msg = getMsgs()
  File "/home/j/py/app.py", line 59, in getMsgs
    response = requests.post(url, headers=headers, json=json.loads(json_data))
  File "/usr/lib/python3/dist-packages/requests/api.py", line 119, in post
    return request('post', url, data=data, json=json, **kwargs)
  File "/usr/lib/python3/dist-packages/requests/api.py", line 61, in request
    return session.request(method=method, url=url, **kwargs)
  File "/usr/lib/python3/dist-packages/requests/sessions.py", line 542, in request
    resp = self.send(prep, **send_kwargs)
  File "/usr/lib/python3/dist-packages/requests/sessions.py", line 655, in send
    r = adapter.send(request, **kwargs)
  File "/usr/lib/python3/dist-packages/requests/adapters.py", line 516, in send
    raise ConnectionError(e, request=request)
requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=5001): Max retries exceeded with url: /email (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x7ff345cc3070>: Failed to establish a new connection: [Errno 111] Connection refused'))
 
 
 
 if json_data:
        url = "http://your-server.com/email"
        headers = {'Content-Type': 'application/json'}
        response = requests.post(url, headers=headers, json=json.loads(json_data))
        if response.status_code == 200:
            print(response.json())
        else:
            print("Request failed with status code", response.status_code)
    else:
        return None



@app.route("/email", methods=['POST'])
def parse_json_data():
    email_body = request.get_json()
    try:
        data = json.loads(email_body)
        account_symbol = data.get("account_symbol")
        account_side = data.get("account_side")
        account_volume = data.get("account_volume")
        order_price = data.get("order_price")

        response = {}
        response['account_symbol'] = account_symbol
        response['account_side'] = account_side
        response['account_volume'] = account_volume
        response['order_price'] = order_price

        return json.dumps(response)
    except json.JSONDecodeError as error:
        print("Error: Unable to parse JSON data.")
        print(error)
        return "Error: Unable to parse JSON data."

def getMsgs(servername="imap.gmx.com"):
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    json_data = get_json_data(email_body)
    if json_data:
        parsed_data = parse_json_data()
        return parsed_data
    else:
        return None
    conn.logout()

def get_json_data(email_body):
    pattern = re.compile(r'{.*}')
    match = pattern.search(email_body)

    if match:
        # Extract the JSON data and parse it
        json_data = match.group()
        return json_data
    else:
        # Return None if no JSON data was found
        return None

if __name__ == '__main__':
    app.run(debug=True)










@app.route('/email', methods=['POST'])
def parse_json_data():
    email_body = request.get_json()
    data = json.loads(email_body)
    return data





























TypeError: parse_json_data() missing 1 required positional argument: 'email_body'
Traceback (most recent call last)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2548, in __call__

    return self.wsgi_app(environ, start_response)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2528, in wsgi_app

    response = self.handle_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app

    response = self.full_dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request

    rv = self.handle_user_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request

    rv = self.dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request

    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)

    TypeError: parse_json_data() missing 1 required positional argument: 'email_body'







def parse_json_data(email_body):
    try:
        data = json.loads(email_body)
        account_symbol = data.get("account_symbol")
        account_side = data.get("account_side")
        account_volume = data.get("account_volume")
        order_price = data.get("order_price")
        
        return (account_symbol, account_side, account_volume, order_price)
    except json.JSONDecodeError as error:
        print("Error: Unable to parse JSON data.")
        print(error)
        return None

def getMsgs(servername="imap.gmx.com"):
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    json_data = get_json_data(email_body)
    if json_data:
        parsed_data = parse_json_data(json_data)
        return parsed_data
    else:
        return None
    conn.logout()

def get_json_data(email_body):
    pattern = re.compile(r'{.*}')
    match = pattern.search(email_body)

    if match:
        # Extract the JSON data and parse it
        json_data = match.group()
        return json_data
    else:
        # Return None if no JSON data was found
        return None

response = {}
msg = getMsgs()
if msg:
    account_symbol, account_side, account_volume, order_price = msg
    response['account_symbol'] = account_symbol
    response['account_side'] = account_side
    response['account_volume'] = account_volume
    response['order_price'] = order_price
else:
    response['error'] = "Unable to retrieve email or no JSON data found in the email."
    return response, 500





py
Traceback (most recent call last):
  File "/home/j/py/app.py", line 53, in <module>
    msg = getMsgs()
  File "/home/j/py/app.py", line 38, in getMsgs
    return json.loads(email_body)
  File "/usr/lib/python3.10/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
  File "/usr/lib/python3.10/json/decoder.py", line 337, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File "/usr/lib/python3.10/json/decoder.py", line 353, in raw_decode
    obj, end = self.scan_once(s, idx)
json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)



get_json_data(email_body):
    pattern = re.compile(r'{.*}')
    match = pattern.search(email_body)

    if match:
        # Extract the JSON data and parse it
        json_data = match.group()
        parsed_data = json.loads(json_data)
        return parsed_data
    else:
        # Return None if no JSON data was found
        return None






    pattern = re.compile(r'{.*}')
    match = pattern.search(email_body)
    
    if match:
        # Extract the JSON data and parse it
        json_data = match.group()
        parsed_data = json.loads(json_data)
        conn.logout()
        return parsed_data
    else:
        # Return None if no JSON data was found
        conn.logout()
        return None

















Traceback (most recent call last)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2548, in __call__

    return self.wsgi_app(environ, start_response)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2528, in wsgi_app

    response = self.handle_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app

    response = self.full_dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request

    rv = self.handle_user_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request

    rv = self.dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request

    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)

    File "/home/j/py/app.py", line 38, in getMsgs

    return json.loads(email_body)

    File "/usr/lib/python3.10/json/__init__.py", line 346, in loads

    return _default_decoder.decode(s)

    File "/usr/lib/python3.10/json/decoder.py", line 337, in decode

    obj, end = self.raw_decode(s, idx=_w(s, 0).end())

    File "/usr/lib/python3.10/json/decoder.py", line 353, in raw_decode

    obj, end = self.scan_once(s, idx)

    json.decoder.JSONDecodeError: Invalid control character at: line 1 column 77 (char 76)







j@j-VirtualBox:~/py$ /home/j/py/.venv/bin/python /home/j/py/app.py
Traceback (most recent call last):
  File "/home/j/py/app.py", line 42, in <module>
    msg = getMsgs()
  File "/home/j/py/app.py", line 38, in getMsgs
    return json.loads(email_body)
  File "/usr/lib/python3.10/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
  File "/usr/lib/python3.10/json/decoder.py", line 340, in decode
    raise JSONDecodeError("Extra data", s, end)
json.decoder.JSONDecodeError: Extra data: line 8 column 1 (char 118)
j@j-VirtualBox:~/py$ 







app = Flask(__name__)
app.debug = True

@app.route('/e')
def getMsgs(servername="imap.gmx.com"):
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    start_index = email_body.find("{")
    end_index = email_body.rfind("}")
    email_body = email_body[start_index:end_index + 1]
    return json.loads(email_body)
    conn.logout()

response = {}
msg = getMsgs()
if msg:
    result = msg.get('result')
    if result:
        response['result'] = result
    else:
        response['error'] = "No result information found in the email"
        return response, 500
    
    account_side = msg.get('Account side')
    if account_side:
        response['account_side'] = account_side
    else:
        response['error'] = "No 'Account side' found in the email body"
        return response, 500

    order_price = msg.get('Price')
    if order_price:
        response['order_price'] = order_price = float(order_price)
    else:
        response['error'] = "No 'Price' found in the email body"
        return response, 500

    account_symbol = msg.get('account_symbol')
    if account_symbol:
        response['account_symbol'] = account_symbol
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response), 500

    account_volume = msg.get('account_volume')
    if account_volume:
        response['account_volume'] = account_volume
    else:





File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2548, in __call__

return self.wsgi_app(environ, start_response)

File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2528, in wsgi_app

response = self.handle_exception(e)

File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app

response = self.full_dispatch_request()

File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1823, in full_dispatch_request

return self.finalize_request(rv)

File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1842, in finalize_request

response = self.make_response(rv)

File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2134, in make_response

raise TypeError(

Traceback (most recent call last)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2548, in __call__

    return self.wsgi_app(environ, start_response)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2528, in wsgi_app

    response = self.handle_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app

    response = self.full_dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request

    rv = self.handle_user_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request

    rv = self.dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request

    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)

    File "/home/j/py/app.py", line 37, in getMsgs

    return json.loads(email_body)

    File "/usr/lib/python3.10/json/__init__.py", line 346, in loads

    return _default_decoder.decode(s)

    File "/usr/lib/python3.10/json/decoder.py", line 337, in decode

    obj, end = self.raw_decode(s, idx=_w(s, 0).end())

    File "/usr/lib/python3.10/json/decoder.py", line 355, in raw_decode

    raise JSONDecodeError("Expecting value", s, err.value) from None

    json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)



from flask import Flask, jsonify
import bybit
import re
import ssl
import certifi
import imaplib
import json
import getpass
import os
import imaplib
import email
from OpenSSL.crypto import load_certificate, FILETYPE_PEM
app = Flask(__name__)
app.debug = True


@app.route('/e')
def getMsgs(servername="imap.gmx.com"):

    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    return json.loads(email_body)
    conn.log()
    conn.logout()


response = {}
msg = getMsgs()
if msg:
    result = msg.get('result')
    if result:
        response['result'] = result
    else:
        response['error'] = "No result information found in the email"

    email_body = json.dumps(msg)
    account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = float(order_price.group(1))
    else:
        response['error'] = "No 'Price' found in the email body"
    account_symbol = re.search(r'account_symbol: (.*)', email_body)
    if account_symbol:
        response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"

    account_volume = re.search(r'account_volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                         api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
              qty=account_volume, price=order_price, time_in_force="gtc").result())
    else:
        print("Cannot place order")



from flask import Flask, jsonify
import bybit
import re
import ssl
import certifi
import imaplib
import json
import getpass
import os
import imaplib
import email
from OpenSSL.crypto import load_certificate, FILETYPE_PEM
app = Flask(__name__)
app.debug = True


@app.route('/e')
def getMsgs(servername="imap.gmx.com"):

    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    return json.loads(email_body)
    conn.log()
    conn.logout()


response = {}
msg = getMsgs()
if msg:
    result = msg.get('result')
    if result:
        response['result'] = result
    else:
        response['error'] = "No result information found in the email"

    email_body = json.dumps(msg)
    account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = float(order_price.group(1))
    else:
        response['error'] = "No 'Price' found in the email body"
    account_symbol = re.search(r'account_symbol: (.*)', email_body)
    if account_symbol:
        response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"

    account_volume = re.search(r'account_volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                         api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
              qty=account_volume, price=order_price, time_in_force="gtc").result())
    else:
        print("Cannot place order")
















from flask import Flask, jsonify
import bybit
import re
import ssl
import certifi
import imaplib
import json
import getpass
import os
import imaplib
import email
from OpenSSL.crypto import load_certificate, FILETYPE_PEM
app = Flask(__name__)
app.debug = True


@app.route('/e')
def getMsgs(servername="imap.gmx.com"):

    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [
        mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    return json.loads(email_body)
    conn.log()
    conn.logout()


response = {}
msg = getMsgs()
if msg:
    result = msg.get('result')
    if result:
        response['result'] = result
    else:
        response['error'] = "No result information found in the email"
        return response, 500
    else:
        response['error'] = "No valid email IDs found in the search results"
        return response, 500

    email_body = json.dumps(msg)
    account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"
        return response, 500

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = float(order_price.group(1))
    else:
        response['error'] = "No 'Price' found in the email body"
        return response, 500
    account_symbol = re.search(r'account_symbol: (.*)', email_body)
    if account_symbol:
        response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response), 500

    account_volume = re.search(r'account_volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
        return jsonify(response), 500
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                         api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
              qty=account_volume, price=order_price, time_in_force="gtc").result())
    else:
        print("Cannot place order")
        






Traceback (most recent call last)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2548, in __call__

    return self.wsgi_app(environ, start_response)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2528, in wsgi_app

    response = self.handle_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app

    response = self.full_dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request

    rv = self.handle_user_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request

    rv = self.dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request

    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)

    File "/home/j/py/app.py", line 38, in execute_trade

    msg = getMsgs()

    File "/home/j/py/app.py", line 29, in getMsgs

    return json.loads(email_body)

    File "/usr/lib/python3.10/json/__init__.py", line 346, in loads

    return _default_decoder.decode(s)

    File "/usr/lib/python3.10/json/decoder.py", line 337, in decode

    obj, end = self.raw_decode(s, idx=_w(s, 0).end())

    File "/usr/lib/python3.10/json/decoder.py", line 355, in raw_decode

    raise JSONDecodeError("Expecting value", s, err.value) from None

    json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)



app.debug = True
@app.route('/e')

def getMsgs(servername="imap.gmx.com"):

    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    return json.loads(email_body)
    conn.log()
    conn.logout()

def execute_trade():
response = {}
msg = getMsgs()
if msg:
    result = msg.get('result')
    if result:
            response['result'] = result
    else:
         response['error'] = "No result information found in the email"
          return response, 500
    else:
        response['error'] = "No valid email IDs found in the search results"
        return response, 500
    
    email_body = json.dumps(msg)
    account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"
        return response, 500

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = float(order_price.group(1))
    else:
        response['error'] = "No 'Price' found in the email body"
        return response, 500
    account_symbol = re.search(r'account_symbol: (.*)', email_body)
    if account_symbol:
     response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response), 500

    account_volume = re.search(r'account_volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
        return jsonify(response), 500
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
           print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",qty=account_volume, price=order_price,time_in_force="gtc").result())
    else:
        print("Cannot place order")














from flask import Flask, jsonify
import bybit
import re
import ssl
import certifi
import imaplib
import json
import getpass, os, imaplib, email
from OpenSSL.crypto import load_certificate, FILETYPE_PEM

def getMsgs(servername="imap.gmx.com"):
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm, passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    return json.loads(email_body)

app = Flask(__name__)
app.debug = True

@app.route('/e')
def execute_trade():
    response = {}
    msg = getMsgs()
    if msg:
        result = msg.get('result')
        if result:
            response['result'] = result
        else:
            response['error'] = "No result information found in the email"
            return response, 500
    else:
        response['error'] = "No valid email IDs found in the search results"
        return response, 500
    
    email_body = json.dumps(msg)
    account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"
        return response, 500

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = float(order_price.group(1))
    else:
        response['error'] = "No 'Price' found in the email body"
        return response, 500

    return response, 200

















from flask import Flask, jsonify
import bybit
import re
import ssl
import certifi
import imaplib
import json
import getpass, os, imaplib, email
from OpenSSL.crypto import load_certificate, FILETYPE_PEM

def getMsgs(servername="imap.gmx.com"):
    usernm = "skullze@gmx.com"
    passwd = "Mando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm,passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    return json.loads(email_body)

app = Flask(__name__)
app.debug = True
@app.route('/e')
def execute_trade():
    response = {}
    msg = getMsgs()
    if msg:
        result = msg.get('result')
        if result:
            response['result'] = result
        else:
            response['error'] = "No result information found in the email"
            return response, 500
    else:
        response['error'] = "No valid email IDs found in the search results"
        return response, 500
    return response, 200      
    account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"
        return response, 500

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = order_price
    else:
        response['error'] = "No 'Price' found in the email body"
        return jsonify(response), 500

    account_symbol = re.search(r'account_symbol: (.*)', email_body)
    if account_symbol:
     response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response), 500

    account_volume = re.search(r'account_volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
        return jsonify(response), 500
    imap.close()
    imap.logout()
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
           print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",qty=account_volume, price=order_price,time_in_force="gtc").result())
    else:
        print("Cannot place order")
#        if "error" in result()
    # Delete the data file on failure
#    os.remove("trade_data.txt")
#    print(order["error"]["message"])
# else:
#    # Delete the data file on success
#    os.remove("trade_data.txt")
#    print("Order placed successfully")
# Cancel the order
# print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
# print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
        print(client.Order.Order_query(symbol='account_symbol').result())
# My Position
        print(client.Positions.Positions_myPosition(
        symbol=account_symbol).result())


if __name__ == '__main__':
    app.run(port=5001)

















import getpass, os, imaplib, email
from OpenSSL.crypto import load_certificate, FILETYPE_PEM
def getMsgs(servername="imap-mail.outlook.com"):
    usernm = "sterxus@outlook.com"
    passwd = "TheMando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    conn = imaplib.IMAP4_SSL(servername, 993, ssl_context=ssl_context)
    conn.login(usernm,passwd)
    conn.select('INBOX', readonly=True)
    typ, data = conn.search(None, "UNSEEN", 'SUBJECT "alert:"')
    mail_ids = data[0].split()
    valid_mail_ids = [mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
    if not valid_mail_ids:
        return None
    mail_id = valid_mail_ids[0]
    typ, email_data = conn.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode('utf-8')
    return json.loads(email_body)

@app.route('/e')
def execute_trade():
    response = {}
    msg = getMsgs()
    if msg:
        result = msg.get('result')
        if result:
            response['result'] = result
        else:
            response['error'] = "No result information found in the email"
            return response, 500
    else:
        response['error'] = "No valid email IDs found in the search results"
        return response, 500
    return response, 200





















from flask import Flask, jsonify
import bybit
import re
import ssl
import certifi
import imaplib

class IMAPError(imaplib.IMAP4.error):
    pass
app = Flask(__name__)
app.debug = True

@app.route('/e')
def execute_trade():
    response = {}
    HOST = "imap.gmx.com"
    USERNAME = "example@gmx.com"
    PASSWORD = "example"

    try:
        ssl_context = ssl.create_default_context(cafile=certifi.where())
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        with imaplib.IMAP4_SSL(HOST, 993, ssl_context=ssl_context) as imap:
            imap.login(USERNAME, PASSWORD)
            imap.select('INBOX',readonly=True)
            mail_ids = imap.search(None, "UNSEEN", 'SUBJECT "Alert:"')[0].split()
            print(mail_ids)
            mail_ids = mail_ids[0].split()
            valid_mail_ids = [mail_id for mail_id in mail_ids if mail_id.strip().isdigit()]
            for mail_id in mail_ids:
                try:
                    int(mail_id)
                    valid_mail_ids.append(mail_id)
                except ValueError:
                    pass
            if not valid_mail_ids:
                response['error'] = "No valid email IDs found in the search results"
                return response, 500
            mail_id = valid_mail_ids[0]
            email_data = imap.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode('utf-8')
            account_side = re.search(r'Account side: (.*)', email_body)
            if account_side:
                response['account_side'] = account_side.group(1)
            else:
                response['error'] = "No account side information found in the email"
                return response, 500
    except (IMAPError, IndexError, UnicodeDecodeError, ssl.SSLError) as e:
        response['error'] = f"Error accessing the email server: {str(e)}"
        return response, 500

    account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"
        return response, 500

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = order_price
    else:
        response['error'] = "No 'Price' found in the email body"
        return jsonify(response), 500

    account_symbol = re.search(r'account_symbol: (.*)', email_body)
    if account_symbol:
     response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response), 500

    account_volume = re.search(r'account_volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
        return jsonify(response), 500
    imap.close()
    imap.logout()
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
           print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",qty=account_volume, price=order_price,time_in_force="gtc").result())

# Query Active Orders(real-time)
        print(client.Order.Order_query(symbol='account_symbol').result())
# My Position
        print(client.Positions.Positions_myPosition(
        symbol=account_symbol).result())


if __name__ == '__main__':
    app.run(port=5000)
    
    
                json_data = json.loads(email_body)
            result = json_data.get('result')
            if result:
                response['result'] = result
            else:
                response['error'] = "No result information found in the email"
                return response, 500
 
 
 
 
 
 
 
 
 
 
 try:
        ssl_context = ssl.create_default_context(cafile=certifi.where())
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        with imaplib.IMAP4_SSL(HOST, 993, ssl_context=ssl_context) as imap:
            imap.login(USERNAME, PASSWORD)
            imap.select('INBOX', readonly=True)
            search_result = imap.search(None, "UNSEEN", 'SUBJECT "alert:"')[0].split()
            valid_mail_ids = [mail_id for mail_id in search_result if mail_id.strip().isalnum()]
            
            if not valid_mail_ids:
                response['error'] = "No valid email IDs found in the search results"
                return response, 500
            
            mail_id = valid_mail_ids[0]
            email_data = imap.fetch(mail_id, "(RFC822)")[0][1]
            email_body = email_data.decode('utf-8')
      
      
      
      
      
      
      
      
      
      
      
      
      
      valid_mail_ids = [mail_id for mail_id in mail_ids if mail_id.strip().isalnum()]
       
       
       
       mail_ids = imap.search(None, "UNSEEN", 'SUBJECT "alert:"')[0].split()
            valid_mail_ids = []
            for mail_id in mail_ids:
                try:
                    int(mail_id)
                    valid_mail_ids.append(mail_id)
                except ValueError:
                    pass
            if not valid_mail_ids:
                response['error'] = "No valid email IDs found in the search results"
                return response, 500
            mail_id = valid_mail_ids[0]
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  def execute_trade():
    response = {}
    HOST = "imap-mail.outlook.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"

    try:
        ssl_context = ssl.create_default_context(cafile=certifi.where())
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        with imaplib.IMAP4_SSL(HOST, 993, ssl_context=ssl_context) as imap:
            imap.login(USERNAME, PASSWORD)
            imap.select('INBOX',readonly=True)
            mail_ids = imap.search(None, "UNSEEN", 'SUBJECT "alert:"')[0].split()
            valid_mail_ids = [mail_id for mail_id in mail_ids if mail_id.isdigit()]
            if not valid_mail_ids:
                response['error'] = "No valid email IDs found in the search results"
                return response, 500
            mail_id = valid_mail_ids[0]
            email_data = imap.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode('utf-8')
            account_side = re.search(r'Account side: (.*)', email_body)
            if account_side:
                response['account_side'] = account_side.group(1)
            else:
                response['error'] = "No account side information found in the email"
                return response, 500
    except (IMAPError, IndexError, UnicodeDecodeError, ssl.SSLError) as e:
        response['error'] = f"Error accessing the email server: {str(e)}"
        return response, 500

    return response





imaplib.IMAP4.error: FETCH command error: BAD [b'The specified message set is invalid.']
Traceback (most recent call last)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2548, in __call__

    return self.wsgi_app(environ, start_response)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2528, in wsgi_app

    response = self.handle_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app

    response = self.full_dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request

    rv = self.handle_user_exception(e)

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request

    rv = self.dispatch_request()

    File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request

    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)

    File "/home/j/py/app.py", line 48, in execute_trade

    email_data = imap.fetch(mail_id, "(RFC822)")

    File "/usr/lib/python3.10/imaplib.py", line 548, in fetch

    typ, dat = self._simple_command(name, message_set, message_parts)

    File "/usr/lib/python3.10/imaplib.py", line 1230, in _simple_command

    return self._command_complete(name, self._command(name, *args))

    File "/usr/lib/python3.10/imaplib.py", line 1055, in _command_complete

    raise self.error('%s command error: %s %s' % (name, typ, data))

class IMAPError(imaplib.IMAP4.error):
    pass
app = Flask(__name__)
app.debug = True

@app.route('/e')
def execute_trade():
    response = {}
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "imap-mail.outlook.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"

    with imaplib.IMAP4_SSL(HOST, 993, ssl_context=ssl_context) as imap:
        try:
            imap.login(USERNAME, PASSWORD)
        except IMAPError as e:
            response['error'] = f"Error logging in to the email server: {str(e)}"
            return response, 500
        try:
            imap.select('INBOX',readonly=True)
        except IMAPError as e:
            response['error'] = f"Error selecting INBOX: {str(e)}"
            return response, 500
        mail_ids = imap.search(None ,"UNSEEN",'SUBJECT "alert:"')[0]
        if not mail_ids:
            response['error'] = "No email IDs found in the search results"
            return response, 500

        mail_ids = mail_ids.split()
        if not mail_ids:
           response['error'] = "No email IDs found in the search results"
           return response, 500

        mail_id = mail_ids[0]
        try:
            email_data = imap.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode('utf-8')
        except (IMAPError, IndexError, UnicodeDecodeError) as e:
            response['error'] = f"Error fetching email with ID {mail_id}: {str(e)}"
            return response, 500

        account_side = re.search(r'Account side: (.*)', email_body)
        if account_side:
            response['account_side'] = account_side = account_side.group(1)
        else:
            response['error'] = "No 'Account side' found in the email body"
            return response, 500

        order_price = re.search(r'Price: (.*)', email_body)
        if order_price:
            response['order_price'] = order_price = order_price
        else:
            response['error'] = "No 'Price' found in the email body"
            return jsonify(response), 500

    account_symbol = re.search(r'account_symbol: (.*)', email_body)
    if account_symbol:
       response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response), 500

    account_volume = re.search(r'account_volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
        return jsonify(response), 500
    imap.close()
    imap.logout()
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",qty=account_volume, price=order_price,time_in_force="gtc").result())
    else:
        print("Cannot place order")
        
        
        
        
        
        
        
        





if not mail_ids:
    response['error'] = "No email IDs found in the search results"
    return response, 500

mail_ids = mail_ids.split()
if not mail_ids:
    response['error'] = "No email IDs found in the search results"
    return response, 500

mail_id = mail_ids[0]





app = Flask(__name__)
app.debug = True

@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "imap-mail.outlook.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    response = {}
    imap = imaplib.IMAP4_SSL(HOST, 993, ssl_context=ssl_context)
    try:
        imap.login(USERNAME, PASSWORD)
    except imaplib.IMAP4.error as e:
        response['error'] = f"Error logging in to the email server: {str(e)}"
        return jsonify(response)
    try:
        imap.select('INBOX',readonly=True)
    except imaplib.IMAP4.error as e:
        response['error'] = f"Error selecting INBOX: {str(e)}"
        return jsonify(response)

    mail_ids = imap.search(None, "SUBJECT \"alert:\" SORT (ARRIVAL DESC)")[0].split("\n")
    if not mail_ids or not mail_ids[0]:
        response['error'] = "No email ID found in the search results"
        return jsonify(response)

    mail_id = mail_ids[0]

    try:
        email_data = imap.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")
    except (imaplib.IMAP4.error, IndexError, UnicodeDecodeError) as e:
        response['error'] = f"Error fetching email with ID {mail_id}: {str(e)}"
        return jsonify(response)

    account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"
        return jsonify(response)

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = order_price.group(1)
    else:
        response['error'] = "No 'Price' found in the email body"
        return jsonify(response)

    account_symbol = re.search(r'Account symbol: (.*)', email_body)
    if account_symbol:
       response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response)

    account_volume = re.search(r'Account volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
        return jsonify(response)
    imap.close()
    imap.logout()
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",qty=account_volume, price=order_price,time_in_force="gtc").result())
    else:
        print("Cannot place order")







mail_ids = imap.search(None, "UNSEEN")[0].split("\n")
if not mail_ids:
    response['error'] = "No email ID found in the search results"
    return jsonify(response)

mail_id = mail_ids[0]




mail_ids = imap.search(None, "SUBJECT \"alert:\" UNSEEN")
This will search for the latest email with a subject that starts with "alert:" and is also unseen. If you want to search for the latest email regardless of whether it is seen or unseen, you can use this search query instead:

less
Copy code
mail_ids = imap.search(None, "SUBJECT \"alert:\" SORT (ARRIVAL DESC)")












#    os.remove("trade_data.txt")
#    print("Order placed successfully")
# Cancel the order
# print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
# print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
    print(client.Order.Order_query(symbol='account_symbol').result())
# My Position
    print(client.Positions.Positions_myPosition(
        symbol=account_symbol).result())


if __name__ == '__main__':
    app.run(port=8082)

# If the order is filled, print a message
# if _myPosition == True:
#    print("Order Active")
# else:
#   print("Order not filled.")











ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "imap-mail.outlook.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    response = {}
    imap = imaplib.IMAP4_SSL(HOST, 993, ssl_context=ssl_context)
    imap.login(USERNAME, PASSWORD)
    imap.select('INBOX',readonly=True)
    return_code, mail_ids = imap.search(None, "UNSEEN")

    if mail_ids and mail_ids[0]:
        mail_id = mail_ids[0].split()[0]
        try:
            email_data = imap.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode("utf-8")
        except:
            imap.close()
            imap.logout()
            response['error'] = f"Error fetching email with ID: {mail_id}"
        else:
            account_side = re.search(r'Account side: (.*)', email_body)
            if account_side:
                response['account_side'] = account_side.group(1)

            order_price = re.search(r'Price: (.*)', email_body)
            if order_price:
                response['order_price'] = order_price.group(1)

            account_symbol = re.search(r'Account symbol: (.*)', email_body)
            if account_symbol:
                response['account_symbol'] = account_symbol.group(1)

            account_volume = re.search(r'Account volume: (.*)', email_body)
            if account_volume:
                response['account_volume'] = account_volume.group(1)
    else:
        response['error'] = "No unseen emails found"

    imap.close()
    imap.logout()
    return response
   
   
   
   
   
   
   
   
   
   
   
   
   
   account_side = re.search(r'Account side: (.*)', email_body)
    if account_side:
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"
        return jsonify(response)

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = order_price.group(1)
    else:
        response['error'] = "No 'Price' found in the email body"
        return jsonify(response)

    account_symbol = re.search(r'Account symbol: (.*)', email_body)
    if account_symbol:
        response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response)

    account_volume = re.search(r'Account volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
        return jsonify(response)
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        response['account_side'] = account_side = account_side.group(1)
    else:
        response['error'] = "No 'Account side' found in the email body"
        return jsonify(response)

    order_price = re.search(r'Price: (.*)', email_body)
    if order_price:
        response['order_price'] = order_price = order_price.group(1)
    else:
        response['error'] = "No 'Price' found in the email body"
        return jsonify(response)

    account_symbol = re.search(r'Account symbol: (.*)', email_body)
    if account_symbol:
        response['account_symbol'] = account_symbol = account_symbol.group(1)
    else:
        response['error'] = "No 'Account symbol' found in the email body"
        return jsonify(response)

    account_volume = re.search(r'Account volume: (.*)', email_body)
    if account_volume:
        response['account_volume'] = account_volume = account_volume.group(1)
    else:
        response['error'] = "No 'Account volume' found in the email body"
        return jsonify(response)













order_price.group(1)

            account_symbol = re.search(r'Account symbol: (.*)', email_body)
            if account_symbol:
                response['account_symbol'] = account_symbol.group(1)

            account_volume = re.search(r'Account volume: (.*)', email_body)
            if account_volume:
                response['account_volume'] = account_volume.group(1)
        else:












from flask import Flask, jsonify
import bybit
import ssl
import certifi
import re
import imaplib

app = Flask(__name__)
app.debug = True

@app.route('/e')
def execute_trade(order_price: int = 0, account_side: str = '', account_volume: int = 0, account_symbol: str = ''):
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "imap-mail.outlook.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    response = {}
    imap = imaplib.IMAP4_SSL(HOST, 993, ssl_context=ssl_context)
    imap.login(USERNAME, PASSWORD)
    imap.select('INBOX',readonly=True)
    unseen_mails = imap.search("UNSEEN")[1][0].split()

    if unseen_mails:
        mail_id = unseen_mails[0].decode("utf-8")
        try:
            result, email_data = imap.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode("utf-8")
        except:
            imap.close()
            imap.logout()
            try:
                return jsonify(response)
            except Exception as e:
                response['error'] = f"Error fetching email with ID: {mail_id}. Error: {str(e)}"
        else:
            account_side = re.search(r'Account side: (.*)', email_body)
            if account_side:
                response['account_side'] = account_side.group(1)

            order_price = re.search(r'Price: (.*)', email_body)
            if order_price:
                response['order_price'] = order_price.group(1)

            account_symbol = re.search(r'Account symbol: (.*)', email_body)
            if account_symbol:
                response['account_symbol'] = account_symbol.group(1)

            account_volume = re.search(r'Account volume: (.*)', email_body)
            if account_volume:
                response['account_volume'] = account_volume.group(1)
        else:
            response['error'] = "No unseen emails found"

    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                        api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    if account_side and account_symbol and account_volume:
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
                                      qty=account_volume, price=order_price,






















from flask import Flask, jsonify
import bybit
import ssl
import certifi
import re
import imaplib
app = Flask(__name__)
app.debug = True

@app.route('/e')
def execute_trade(order_price: int = 0, account_side: str = '', account_volume: int = 0, account_symbol: str = ''):
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "imap-mail.outlook.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    response = {}
    imap = imaplib.IMAP4_SSL(HOST, 993, ssl_context=ssl_context)
    imap.login(USERNAME, PASSWORD)
    imap.select('INBOX',readonly=True)
    unseen_mails = imap.search("UNSEEN")[1][0].split()

    if unseen_mails:
        mail_id = unseen_mails[0].decode("utf-8")

try:
    result, email_data = imap.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode("utf-8")
except:
        imap.close()
        imap.logout()
        
        try:
            return jsonify(response)
        except Exception as e:
            response['error'] = f"Error fetching email with ID: {mail_id}. Error: {str(e)}"
    else:
        account_side = re.search(r'Account side: (.*)', email_body)
        if account_side:
           response['account_side'] = account_side.group(1)

        order_price = re.search(r'Price: (.*)', email_body)
        if order_price:
            response['order_price'] = order_price.group(1)

        account_symbol = re.search(r'Account symbol: (.*)', email_body)
        if account_symbol:
            response['account_symbol'] = account_symbol.group(1)

        account_volume = re.search(r'Account volume: (.*)', email_body)
        if account_volume:
            response['account_volume'] = account_volume.group(1)
        else:
            response['error'] = "No unseen emails found"
#except ValueError as e:
#    if "invalid literal for int() with base 10: 'None'" in str(e):
 #       print("error occured")
#    else:
#        raise e

    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                     api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

# Place the order
    if account_side and account_symbol and account_volume:
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="limit",
              qty=account_volume, price=order_price, time_in_force="gtc").result())
    else:
        print("Cannot place order")



















# Read the data from the file
with open("email_data.txt", "r") as f:
lines = f.readlines()
account_side = lines[0].strip().split(":")[1].strip()
account_symbol = lines[1].strip().split(":")[1].strip()
account_volume = lines[2].strip().split(":")[1].strip()





# Save data to file
with open("trade_data.txt", "w") as f:
    f.write(f"Account side: {account_side}\nAccount symbol: {account_symbol}\nAccount volume: {account_volume}")

# Initialize the Bybit client
client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

# Place the order
order = client.Order.Order_new(side=account_side, symbol=account_symbol, order_type="", qty=account_volume, price="", time_in_force="").result()
print(order)

if "error" in order:
    # Delete the data file on failure
    os.remove("trade_data.txt")
    return order["error"]["message"]
else:
    # Delete the data file on success
    os.remove("trade_data.txt")
    return "Order placed successfully"


































from flask import Flask
import json
import bybit
import ssl
import certifi
import re
from imapclient import IMAPClient

app = Flask(__name__)

@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    try:
        with IMAPClient(HOST, 993, ssl_context=ssl_context) as server:
            server.login(USERNAME, PASSWORD)
            imap_server = server.select_folder('INBOX')
            # Search for the unread emails
            unseen_mails = server.search(["UNSEEN"])
            print(unseen_mails)
            account_side = None
            if unseen_mails:
                mail_id = str(unseen_mails[0]).split()[0]
                try:
                    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                    email_body = email_data[0][1].decode("utf-8")
                except:
                    print("Error fetching email with ID:", mail_id)
                else:
                    account_side = re.search(r'Account side: (.*)', email_body)
                    if account_side:
                        account_side = account_side.group(1)
                    else:
                        account_side = None

                    account_symbol = re.search(r'Account symbol: (.*)', email_body)
                    if account_symbol:
                        account_symbol = account_symbol.group(1)
                    else:
                        account_symbol = None

                    account_volume = re.search(r'Account volume: (.*)', email_body)
                    if account_volume:
                        account_volume = account_volume.group(1)
                    else:
                        account_volume = None
    except Exception as e:
        print("An error occured")
        print(e)
    return "done"

if __name__ == '__main__'












getting these errors:
An error occured
[2023-01-31 04:34:36,515] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 29, in execute_trade
    unseen_mails = server.search(["UNSEEN"])
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1115, in search
    return self._search(criteria, charset)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1141, in _search
    data = self._raw_command_untagged(b"SEARCH", args)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1639, in _raw_command_untagged
    typ, data = self._raw_command(command, args, uid=uid)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1697, in _raw_command
    self._imap.send(out)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/tls.py", line 62, in send
    self.sock.sendall(data)
  File "/usr/lib/python3.10/ssl.py", line 1240, in sendall
    return super().sendall(data, flags)
OSError: [Errno 9] Bad file descriptor
in this script can you write a fixed version:
rom flask import Flask
import json
import bybit
import ssl
import certifi
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/e')

@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    try:
         with IMAPClient(HOST, 993, ssl_context=ssl_context) as server:
          server.login(USERNAME, PASSWORD)
         imap_server = server.select_folder('INBOX')
    except:
     print("An error occured")
        # Search for the unread emails
    unseen_mails = server.search(["UNSEEN"])
    print(unseen_mails)
    account_side = None
    if unseen_mails:
            mail_id = str(unseen_mails[0]).split()[0]
            try:
                _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                email_body = email_data[0][1].decode("utf-8")
            except:
                print("Error fetching email with ID:", mail_id)
            else:
                account_side = re.search(r'Account side: (.*)', email_body)
                if account_side:
                    account_side = account_side.group(1)
                else:
                    account_side = None

                account_symbol = re.search(r'Account symbol: (.*)', email_body)
                if account_symbol:
                    account_symbol = account_symbol.group(1)
                else:
                    account_symbol = None

                account_order_type = re.search(r'Order type: (.*)', email_body)
                if account_order_type:
                    account_order_type = account_order_type.group(1)
                else:
                    account_order_type = None

                account_qty = re.search(r'Order contracts: (.*)', email_body)
                if account_qty:
                    account_qty = account_qty.group(1)
                else:
                    account_qty = None

                account_price = re.search(r'Order price: (.*)', email_body)
                if account_price:
                    account_price = account_price.group(1)
                else:
                    account_price = None

                account_time_in_force = re.search(r'Time in force: (.*)', email_body)
                if account_time_in_force:
                    account_time_in_force = account_time_in_force.group(1)
                else:
                    account_time_in_force = None

                passphrase = re.search(r'Passphrase: (.*)', email_body)
                if passphrase:
                    passphrase = passphrase.group(1)
                else:
                    passphrase = None

                timeframe = re.search(r'Timeframe: (.*)', email_body)
                if timeframe:
                 timeframe = timeframe.group(1)
                else:
                 timeframe = None
                    # Mark the email as seen
                imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])

                    # Perform the trade execution steps here
                    # ...
    else:
     print("No unread emails found")
    try:
        server.login()
    except Exception as e:
     print("Error connecting to the IMAP server:", str(e))

    try:
        server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))

    # Initialize the Bybit client
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",                            api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
# get the order ID from the response
        print(client.Order.Order_getOrders(symbol=account_symbol).result())

# Cancel the order
# print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
# print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
        print(client.Order.Order_query(symbol='account_symbol').result())
# My Position
        print(client.Positions.Positions_myPosition(
        symbol='account_symbol').result())

if __name__ == '__main__':
    app.run(port=8080)

# If the order is filled, print a message
# if _myPosition == True:
#    print("Order Active")
# else:
#   print("Order not filled.")





    except Exception as e:
     print("Error connecting to the IMAP server:", str(e))

    try:
        server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))

    # Initialize the Bybit client
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",                            api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
# get the order ID from the response
        print(client.Order.Order_getOrders(symbol=account_symbol).result())







app = Flask(__name__)


@app.route('/e')

@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
HOST = "outlook.office365.com"
USERNAME = "sterxus@outlook.com"
PASSWORD = "TheMando321!"
try:
    with IMAPClient(HOST, 993, ssl_context=ssl_context) as server:
        server.login(USERNAME, PASSWORD)
    imap_server = server.select_folder('INBOX')
except:
    print("An error occured")
        # Search for the unread emails
    unseen_mails = server.search(["UNSEEN"])
    print(unseen_mails)
    account_side = None
    if unseen_mails:
            mail_id = str(unseen_mails[0]).split()[0]
            try:
                _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                email_body = email_data[0][1].decode("utf-8")
            except:
                print("Error fetching email with ID:", mail_id)
            else:
                account_side = re.search(r'Account side: (.*)', email_body)
                if account_side:
                    account_side = account_side.group(1)
                else:
                    account_side = None

                account_symbol = re.search(r'Account symbol: (.*)', email_body)
                if account_symbol:
                    account_symbol = account_symbol.group(1)
                else:
                    account_symbol = None

                account_order_type = re.search(r'Order type: (.*)', email_body)
                if account_order_type:
                    account_order_type = account_order_type.group(1)
                else:
                    account_order_type = None

                account_qty = re.search(r'Order contracts: (.*)', email_body)
                if account_qty:
                    account_qty = account_qty.group(1)
                else:
                    account_qty = None

                account_price = re.search(r'Order price: (.*)', email_body)
                if account_price:
                    account_price = account_price.group(1)
                else:
                    account_price = None

                account_time_in_force = re.search(r'Time in force: (.*)', email_body)
                if account_time_in_force:
                    account_time_in_force = account_time_in_force.group(1)
                else:
                    account_time_in_force = None

                passphrase = re.search(r'Passphrase: (.*)', email_body)
                if passphrase:
                    passphrase = passphrase.group(1)
                else:
                    passphrase = None

timeframe = re.search(r'Timeframe: (.*)', email_body)
if timeframe:
    timeframe = timeframe.group(1)
else:
    timeframe = None
                    # Mark the email as seen
                    imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])

                    # Perform the trade execution steps here
                    # ...
            else:
                print("No unread emails found")
    except Exception as e:
        print("Error connecting to the IMAP server:", str(e))

    try:
        server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))

    # Initialize the Bybit client
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",                            api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
# get the order ID from the response
        print(client.Order.Order_getOrders(symbol=account_symbol).result())

















try:
    with IMAPClient(HOST, 993, ssl_context=ssl_context) as server:
        server.login(USERNAME, PASSWORD)
        imap_server = server.select_folder('INBOX')

        # Search for the unread emails
        unseen_mails = server.search(["UNSEEN"])
        print(unseen_mails)
        account_side = None
        if unseen_mails:
            mail_id = str(unseen_mails[0]).split()[0]
            try:
                _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                email_body = email_data[0][1].decode("utf-8")
            except:
                print("Error fetching email with ID:", mail_id)
            else:
                account_side = re.search(r'Account side: (.*)', email_body)
                if account_side:
                    account_side = account_side.group(1)
                else:
                    account_side = None

                account_symbol = re.search(r'Account symbol: (.*)', email_body)
                if account_symbol:
                    account_symbol = account_symbol.group(1)
                else:
                    account_symbol = None

                account_order_type = re.search(r'Order type: (.*)', email_body)
                if account_order_type:
                    account_order_type = account_order_type.group(1)
                else:
                    account_order_type = None

                account_qty = re.search(r'Order contracts: (.*)', email_body)
                if account_qty:
                    account_qty = account_qty.group(1)
                else:
                    account_qty = None

                account_price = re.search(r'Order price: (.*)', email_body)
                if account_price:
                    account_price = account_price.group(1)
                else:
                    account_price = None

                account_time_in_force = re.search(r'Time in force: (.*)', email_body)
                if account_time_in_force:
                    account_time_in_force = account_time_in_force.group(1)
                else:
                    account_time_in_force = None

                passphrase = re.search(r'Passphrase: (.*)', email_body)
                if passphrase:
                    passphrase = passphrase.group(1)
                else:
                    passphrase = None














fix the indentation on this script:
@app.route('/e')

@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"

    try:
        with IMAPClient(HOST, 993, ssl_context=ssl_context) as server:
            server.login(USERNAME, PASSWORD)
            imap_server = server.select_folder('INBOX')

            # Search for the unread emails
            unseen_mails = server.search(["UNSEEN"])
            print(unseen_mails)
            account_side = None
            if unseen_mails:
                mail_id = str(unseen_mails[0]).split()[0]
                try:
                    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                    email_body = email_data[0][1].decode("utf-8")
                except:
                    print("Error fetching email with ID:", mail_id)
                else:
                 account_side = re.search(r'Account side: (.*)', email_body)
                 if account_side:
                  account_side = account_side.group(1)
                 else:
                  account_side = None

account_symbol = re.search(r'Account symbol: (.*)', email_body)
if account_symbol:
    account_symbol = account_symbol.group(1)
else:
    account_symbol = None

account_order_type = re.search(r'Order type: (.*)', email_body)
if account_order_type:
    account_order_type = account_order_type.group(1)
else:
    account_order_type = None

account_qty = re.search(r'Order contracts: (.*)', email_body)
if account_qty:
    account_qty = account_qty.group(1)
else:
    account_qty = None

account_price = re.search(r'Order price: (.*)', email_body)
if account_price:
    account_price = account_price.group(1)
else:
    account_price = None

account_time_in_force = re.search(r'Time in force: (.*)', email_body)
if account_time_in_force:
    account_time_in_force = account_time_in_force.group(1)
else:
    account_time_in_force = None

passphrase = re.search(r'Passphrase: (.*)', email_body)
if passphrase:
    passphrase = passphrase.group(1)
else:
    passphrase = None

timeframe = re.search(r'Timeframe: (.*)', email_body)
if timeframe:
    timeframe = timeframe.group(1)
else:
    timeframe = None
                    # Mark the email as seen
                    imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])

                    # Perform the trade execution steps here
                    # ...
            else:
                print("No unread emails found")
    except Exception as e:
        print("Error connecting to the IMAP server:", str(e))

    try:
        server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))

    # Initialize the Bybit client
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",                            api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
# get the order ID from the response
        print(client.Order.Order_getOrders(symbol=account_symbol).result())





account_side = re.search(r'Account side: (.*)', email_body)
if account_side:
    account_side = account_side.group(1)
else:
    account_side = None

account_symbol = re.search(r'Account symbol: (.*)', email_body)
if account_symbol:
    account_symbol = account_symbol.group(1)
else:
    account_symbol = None

account_order_type = re.search(r'Order type: (.*)', email_body)
if account_order_type:
    account_order_type = account_order_type.group(1)
else:
    account_order_type = None

account_qty = re.search(r'Order contracts: (.*)', email_body)
if account_qty:
    account_qty = account_qty.group(1)
else:
    account_qty = None

account_price = re.search(r'Order price: (.*)', email_body)
if account_price:
    account_price = account_price.group(1)
else:
    account_price = None

account_time_in_force = re.search(r'Time in force: (.*)', email_body)
if account_time_in_force:
    account_time_in_force = account_time_in_force.group(1)
else:
    account_time_in_force = None

passphrase = re.search(r'Passphrase: (.*)', email_body)
if passphrase:
    passphrase = passphrase.group(1)
else:
    passphrase = None

timeframe = re.search(r'Timeframe: (.*)', email_body)
if timeframe:
    timeframe = timeframe.group(1)
else:
    timeframe = None





app = Flask(__name__)


@app.route('/e')

@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"

    try:
        with IMAPClient(HOST, 993, ssl_context=ssl_context) as server:
            server.login(USERNAME, PASSWORD)
            imap_server = server.select_folder('INBOX')

            # Search for the unread emails
            unseen_mails = server.search(["UNSEEN"])
            print(unseen_mails)

            if unseen_mails:
                mail_id = str(unseen_mails[0]).split()[0]
                try:
                    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                    email_body = email_data[0][1].decode("utf-8")
                except:
                    print("Error fetching email with ID:", mail_id)
                else:
                    # Extract the trade parameters from the email
                    account_side = re.search(r'Account side: (.*)', email_body).group(1)
                    if account_side:
                        account_side = account_side.group(1)
                    account_symbol = re.search(
                        r'Account symbol: (.*)', email_body).group(1)
                    account_order_type = re.search(
                        r'Order type: (.*)', email_body).group(1)
                    account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
                    account_price = re.search(r'Order price: (.*)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)
                    passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
                    timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)
                    account_qty = int(account_qty)
                    # Mark the email as seen
                    imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])

                    # Perform the trade execution steps here
                    # ...
            else:
                print("No unread emails found")
    except Exception as e:
        print("Error connecting to the IMAP server:", str(e))

    try:
        server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))

    # Initialize the Bybit client
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",                            api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
# get the order ID from the response
        print(client.Order.Order_getOrders(symbol=account_symbol).result())

# Cancel the order
# print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
# print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
        print(client.Order.Order_query(symbol='account_symbol').result())
# My Position
        print(client.Positions.Positions_myPosition(
        symbol='account_symbol').result())

if __name__ == '__main__':
    app.run(port=8080)



Press CTRL+C to quit
[6031, 6179, 6181, 6183, 6185, 6187, 6189, 6191, 6193, 6195, 6197]
Error fetching email with ID: 6031
Error logging out from the IMAP server: socket error: [Errno 9] Bad file descriptor
[2023-01-31 03:30:57,940] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/usr/lib/python3.10/imaplib.py", line 1006, in _command
    self.send(data + CRLF)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/tls.py", line 62, in send
    self.sock.sendall(data)
  File "/usr/lib/python3.10/ssl.py", line 1240, in sendall
    return super().sendall(data, flags)
OSError: [Errno 9] Bad file descriptor

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/j/py/app.py", line 68, in execute_trade
    server.logout()
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 513, in logout
    typ, data = self._imap.logout()
  File "/usr/lib/python3.10/imaplib.py", line 642, in logout
    typ, dat = self._simple_command('LOGOUT')
  File "/usr/lib/python3.10/imaplib.py", line 1230, in _simple_command
    return self._command_complete(name, self._command(name, *args))
  File "/usr/lib/python3.10/imaplib.py", line 1008, in _command
    raise self.abort('socket error: %s' % val)
imaplib.IMAP4.abort: socket error: [Errno 9] Bad file descriptor

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 75, in execute_trade
    print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
UnboundLocalError: local variable 'account_side' referenced before assignment



getting these errors in the script below:
[6031, 6179, 6181, 6183, 6185, 6187, 6189, 6191, 6193]
Error fetching email with ID: 6031
Error logging out from the IMAP server: 'dict' object has no attribute 'logout'
[2023-01-31 03:24:04,317] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/py/app.py", line 66, in execute_trade
    imap_server.logout()
AttributeError: 'dict' object has no attribute 'logout'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 73, in execute_trade
    print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
UnboundLocalError: local variable 'account_side' referenced before assignment 
 script:
 rom flask import Flask
import json
import bybit
import ssl
import certifi
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/e')

@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"

    try:
        with IMAPClient(HOST, 993, ssl_context=ssl_context) as server:
            server.login(USERNAME, PASSWORD)
            imap_server = server.select_folder('INBOX')

            # Search for the unread emails
            unseen_mails = server.search(["UNSEEN"])
            print(unseen_mails)

            if unseen_mails:
                mail_id = str(unseen_mails[0]).split()[0]
                try:
                    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                    email_body = email_data[0][1].decode("utf-8")
                except:
                    print("Error fetching email with ID:", mail_id)
                else:
                    # Extract the trade parameters from the email
                    account_side = re.search(r'Account side: (.*)', email_body).group(1)
                    account_symbol = re.search(
                        r'Account symbol: (.*)', email_body).group(1)
                    account_order_type = re.search(
                        r'Order type: (.*)', email_body).group(1)
                    account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
                    account_price = re.search(r'Order price: (.*)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)
                    passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
                    timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)
                    account_qty = int(account_qty)
                    # Mark the email as seen
                    imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])

                    # Perform the trade execution steps here
                    # ...
            else:
                print("No unread emails found")
    except Exception as e:
        print("Error connecting to the IMAP server:", str(e))

    try:
        imap_server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))

    # Initialize the Bybit client
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",                            api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
# get the order ID from the response
        print(client.Order.Order_getOrders(symbol=account_symbol).result())

# Cancel the order
# print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
# print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
        print(client.Order.Order_query(symbol='account_symbol').result())
# My Position
        print(client.Positions.Positions_myPosition(
        symbol='account_symbol').result())

if __name__ == '__main__':
    app.run(port=8080)

# If the order is filled, print a message
# if _myPosition == True:
#    print("Order Active")
# else:
#   print("Order not filled.")



 
 
 
app = Flask(__name__)


@app.route('/e')

@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"

    try:
        with IMAPClient(HOST, 993, ssl_context=ssl_context) as server:
            server.login(USERNAME, PASSWORD)
            imap_server = server.select_folder('INBOX')

            # Search for the unread emails
            unseen_mails = server.search(["UNSEEN"])
            print(unseen_mails)

            if unseen_mails:
                mail_id = str(unseen_mails[0]).split()[0]
                try:
                    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                    email_body = email_data[0][1].decode("utf-8")
                except:
                    print("Error fetching email with ID:", mail_id)
                else:
                    # Extract the trade parameters from the email
                    account_side = re.search(r'Account side: (.*)', email_body).group(1)
                    account_symbol = re.search(
                        r'Account symbol: (.*)', email_body).group(1)
                    account_order_type = re.search(
                        r'Order type: (.*)', email_body).group(1)
                    account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
                    account_price = re.search(r'Order price: (.*)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)
                    passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
                    timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)

                    # Mark the email as seen
                    imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])

                    # Perform the trade execution steps here
                    # ...
            else:
                print("No unread emails found")
    except Exception as e:
        print("Error connecting to the IMAP server:", str(e))

    try:
        imap_server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))

    # Initialize the Bybit client
client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",                            api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
print(client.Order.Order_new(side='account_side, symbol=account_symbol', order_type='account_order_type',
qty='account_qty', price='account_price, time_in_force=account_time_in_force').result())
# get the order ID from the response
print(client.Order.Order_getOrders(symbol='account_symbol').result())

# Cancel the order
# print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
# print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
print(client.Order.Order_query(symbol='account_symbol').result())
# My Position
print(client.Positions.Positions_myPosition(
        symbol='account_symbol').result())

if __name__ == '__main__':
    app.run(port=8080)

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 /home/j/py/.venv/bin/python /home/j/py/app.py
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/marshal.py", line 395, in _marshal_primitive_type
    return swagger_format.to_wire(value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/formatter.py", line 191, in <lambda>
    to_wire=lambda i: i if isinstance(i, int) else int(i),
ValueError: invalid literal for int() with base 10: 'account_qty'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/j/py/app.py", line 73, in <module>
    print(client.Order.Order_new(side='account_side, symbol=account_symbol', order_type='account_order_type',
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 246, in __call__
    request_params = construct_request(
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 285, in construct_request
    construct_params(operation, request, op_kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 308, in construct_params
    marshal_param(param, param_value, request)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/param.py", line 130, in marshal_param
    value = marshal_schema_object(swagger_spec, param_spec, value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/marshal.py", line 54, in marshal_schema_object
    return marshaling_method(value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/_decorators.py", line 55, in wrapper
    return func(value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/marshal.py", line 397, in _marshal_primitive_type
    raise SwaggerMappingError(
bravado_core.exception.SwaggerMappingError: ('Error while marshalling value=account_qty to type=number/int32.', ValueError("invalid literal for int() with base 10: 'account_qty'"))
















@app.route('/e')
def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"

    try:
        with IMAPClient(HOST, ssl_context=ssl_context, port=993) as server:
            server.login(USERNAME, PASSWORD)
            imap_server = server.select_folder('INBOX')

            # Search for the unread emails
            unseen_mails = server.search(["UNSEEN"])
            print(unseen_mails)

            if unseen_mails:
                mail_id = str(unseen_mails[0]).split()[0]
                try:
                    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
                    email_body = email_data[0][1].decode("utf-8")
                except:
                    print("Error fetching email with ID:", mail_id)
                else:
                    # Extract the trade parameters from the email
                    account_side = re.search(r'Account side: (.*)', email_body).group(1)
                    account_symbol = re.search(
                        r'Account symbol: (.*)', email_body).group(1)
                    account_order_type = re.search(
                        r'Order type: (.*)', email_body).group(1)
                    account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
                    account_price = re.search(r'Order price: (.*)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)
                    passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
                    timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
                    account_time_in_force = re.search(
                        r'Time in force: (.*)', email_body).group(1)

                    # Mark the email as seen
                    imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])

                    # Perform the trade execution steps here
                    # ...
            else:
                print("No unread emails found")
    except Exception as e:
        print("Error connecting to the IMAP server:", str(e))

    try:
        imap_server.logout()
    except Exception as e:
        print("Error logging out from the IMAP server:", str(e))


















app = Flask(__name__)


@app.route('/e')

def execute_trade():
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
HOST = "outlook.office365.com"
USERNAME = "sterxus@outlook.com"
PASSWORD = "TheMando321!"
   try:
        with IMAPClient(HOST, ssl_context=ssl_context, port=993) as server:
     server.login(USERNAME, PASSWORD)
     imap_server = server.select_folder('INBOX')

    # Search for the unread emails
        unseen_mails = server.search(["UNSEEN"])
        print(unseen_mails)

    if unseen_mails:
        mail_id = str(unseen_mails[0]).split()[0]
    try:
        _, email_data = imap_server.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")
    except:
        print("Error fetching email with ID:", mail_id)
        return

    else:
        print("No unread emails found")
        return
except Exception as e:
    print("Error connecting to the IMAP server:", str(e))
    return

# Perform the trade execution steps here
# ...

try:
    imap_server.logout()
except Exception as e:
    print("Error logging out from the IMAP server:", str(e))
    return

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(
            r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(
            r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(
            r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(
            r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")




else:
            print("No unread emails found")
            return
except Exception as e:
    print("Error connecting to the IMAP server:", str(e))
    return

# Perform the trade execution steps here
# ...

try:
    imap_server.logout()
except Exception as e:
    print("Error logging out from the IMAP server:", str(e))
    return













[6031, 6179, 6181, 6183]
Error fetching email with ID: 6031
[2023-01-31 01:47:00,574] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/py/app.py", line 31, in execute_trade
    _, email_data = server.fetch(mail_id, "(RFC822)")
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1383, in fetch
    tag = self._imap._command(*args)
  File "/usr/lib/python3.10/imaplib.py", line 968, in _command
    raise self.error("command %s illegal in state %s, "
imaplib.IMAP4.error: command UID illegal in state LOGOUT, only allowed in states SELECTED

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/lib/python3.10/imaplib.py", line 1006, in _command
    self.send(data + CRLF)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/tls.py", line 62, in send
    self.sock.sendall(data)
  File "/usr/lib/python3.10/ssl.py", line 1240, in sendall
    return super().sendall(data, flags)
OSError: [Errno 9] Bad file descriptor

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 35, in execute_trade
    server.logout()
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 513, in logout
    typ, data = self._imap.logout()
  File "/usr/lib/python3.10/imaplib.py", line 642, in logout
    typ, dat = self._simple_command('LOGOUT')
  File "/usr/lib/python3.10/imaplib.py", line 1230, in _simple_command
    return self._command_complete(name, self._command(name, *args))
  File "/usr/lib/python3.10/imaplib.py", line 1008, in _command
    raise self.abort('socket error: %s' % val)
imaplib.IMAP4.abort: socket error: [Errno 9] Bad file descriptor




im getting these errors in my script below can you give me a fix
2023-01-31 01:33:46,791] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 26, in execute_trade
    unseen_mails = imap_server.search(["UNSEEN"])
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1115, in search
    return self._search(criteria, charset)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1141, in _search
    data = self._raw_command_untagged(b"SEARCH", args)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1639, in _raw_command_untagged
    typ, data = self._raw_command(command, args, uid=uid)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1697, in _raw_command
    self._imap.send(out)
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/tls.py", line 62, in send
    self.sock.sendall(data)
  File "/usr/lib/python3.10/ssl.py", line 1240, in sendall
    return super().sendall(data, flags)
OSError: [Errno 9] Bad file descriptor
server.select_folder('INBOX')
[2023-01-31 01:26:27,168] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 25, in execute_trade
    unseen_mails = imap_server.search(["UNSEEN"])
AttributeError: 'dict' object has no attribute 'search'
def execute_trade():
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    with IMAPClient(HOST, ssl_context=ssl_context, port=993) as server:
        server.login(USERNAME, PASSWORD)
        imap_server = server.select_folder('INBOX')

    # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])

    if unseen_mails:
        mail_id = str(unseen_mails[0]).split()[0]
        try:
            _, email_data = imap_server.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode("utf-8")
        except:
            print("Error fetching email with ID:", mail_id)
            imap_server.logout()
            return "Error fetching email with ID: " + mail_id





@app.route('/e')
def execute_trade():
    HOST = "outlook.office365.com"
    USERNAME = "sterxus@outlook.com"
    PASSWORD = "TheMando321!"
    ssl_context = ssl.create_default_context(cafile=certifi.where())
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    with IMAPClient(HOST, ssl_context=ssl_context,port =993) as server:
        server.login(USERNAME, PASSWORD)
    imap_server = server.select_folder('INBOX')

    # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])

    if unseen_mails:
        mail_id = str(unseen_mails[0]).split()[0]
        try:
            _, email_data = imap_server.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode("utf-8")
        except:
            print("Error fetching email with ID:", mail_id)
            imap_server.logout()
            return "Error fetching email with ID: " + mail_id

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")
        imap_server.log
        imap_server.logout()

    # Initialize the Bybit client
        client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
        print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type, qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())   
# get the order ID from the response
        print(client.Order.Order_getOrders(symbol=account_symbol).result())


with IMAPClient(HOST, ssl_context=ssl_context) as server:
    server.login(USERNAME, PASSWORD)



   ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True, ssl_context=ssl_context)
imap_server.login('sterxus@outlook.com', 'TheMando321!')
imap_server.select_folder('INBOX')
   
   
   
   
   
   
   
   
   
   
   
   
   imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

    # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])

    if unseen_mails:
        mail_id = str(unseen_mails[0]).split()[0]
        try:
            _, email_data = imap_server.fetch(mail_id, "(RFC822)")
            email_body = email_data[0][1].decode("utf-8")
        except:
            print("Error fetching email with ID:", mail_id)
            imap_server.logout()
            return "Error fetching email with ID: " + mail_id

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")
        imap_server.log



























Can you fix these errros in the script below:       
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 23, in execute_trade
    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
  File "/home/j/.local/lib/python3.10/site-packages/imapclient/imapclient.py", line 1384, in fetch
    typ, data = self._imap._command_complete("FETCH", tag)
  File "/usr/lib/python3.10/imaplib.py", line 1055, in _command_complete
    raise self.error('%s command error: %s %s' % (name, typ, data))
imaplib.IMAP4.error: FETCH command error: BAD [b'Command Argument Error. 11']
from flask import Flask
import json
import bybit
import time
import re
from imapclient import IMAPClient


app = Flask(__name__)


@app.route('/e')
def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

   # Search for the unread emails

    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails and unseen_mails[0]:
        mail_id = str(unseen_mails[0]).split()[0]
        _, email_data = imap_server.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")
        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()

    # Initialize the Bybit client
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
    print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
          qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())   
# get the order ID from the response
    print(client.Order.Order_getOrders(symbol=account_symbol).result())

# Cancel the order
#print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
#print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
#print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
    print(client.Order.Order_query(symbol=account_symbol).result())

# My Position
    print(client.Positions.Positions_myPosition(symbol=account_symbol).result())

if __name__ == '__main__':
    app.run()

# If the order is filled, print a message
#if _myPosition == True:
#    print("Order Active")
#else:
#   print("Order not filled.")







unseen_mails = imap_server.search(["UNSEEN"])
if unseen_mails and unseen_mails[0]:
    mail_id = str(unseen_mails[0]).split()[0https://github.com/skulzz/LONG-SHORT-BOT-WITH-DUAL-TRADES/blame/main/oraganized]
    _, email_data = imap_server.fetch(mail_id, "(RFC822)")
    email_body = email_data[0][1].decode("utf-8")











2023-01-30 22:49:54,694] ERROR in app: Exception on /e [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 21, in execute_trade
    mail_id = unseen_mails[0].decode().split()[0]
AttributeError: 'int' object has no attribute 'decode'













404 -
[2023-01-30 22:29:26,795] ERROR in app: Exception on / [GET]
Traceback (most recent call last):
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 2525, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1822, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1820, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/j/.local/lib/python3.10/site-packages/flask/app.py", line 1796, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
  File "/home/j/py/app.py", line 21, in execute_trade
    mail_id = unseen_mails[0].split()[0]
AttributeError: 'int' object has no attribute 'split'
from flask import Flask
import json
import bybit
import time
import re
from imapclient import IMAPClient


app = Flask(__name__)


@app.route('/e')
def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

   # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails[0] != b'':
        mail_id = unseen_mails[0].split()[0]
        _, email_data = imap_server.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()

    # Initialize the Bybit client
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
    # Place the order
    print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
          qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())   
# get the order ID from the response
    print(client.Order.Order_getOrders(symbol=account_symbol).result())

# Cancel the order
#print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
#print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
#print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
    print(client.Order.Order_query(symbol=account_symbol).result())

# My Position
    print(client.Positions.Positions_myPosition(symbol=account_symbol).result())

if __name__ == '__main__':
    app.run()

# If the order is filled, print a message
#if _myPosition == True:
#    print("Order Active")
#else:
#   print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    # Search for the unread emails
    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails[0] != b'':
        mail_id = unseen_mails[0].split()[0]
        _, email_data = imap_server.fetch(mail_id, "(RFC822)")
        email_body = email_data[0][1].decode("utf-8")

        # Extract the trade parameters from the email
        account_side = re.search(r'Account side: (.*)', email_body).group(1)
        account_symbol = re.search(r'Account symbol: (.*)', email_body).group(1)
        account_order_type = re.search(r'Order type: (.*)', email_body).group(1)
        account_qty = re.search(r'Order contracts: (.*)', email_body).group(1)
        account_price = re.search(r'Order price: (.*)', email_body).group(1)
        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)
        passphrase = re.search(r'Passphrase: (.)', email_body).group(1)
        timeframe = re.search(r'Timeframe: (.)', email_body).group(


        account_time_in_force = re.search(r'Time in force: (.*)', email_body).group(1)

        # Mark the email as seen
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()

    # Initialize the Bybit client
    client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                         api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

    # Place the order
    print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
          qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())














    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails:
        mail_id = list(unseen_mails)[0]
        email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
        email_body = email_data.get_body().decode()
        passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
        strategy_position_size = re.search(
            r'Position size: (.*)', email_body).group(1)
        strategy_order_action = re.search(
            r'Order action: (.*)', email_body).group(1)
        strategy_order_contracts = re.search(
            r'Order contracts: (.*)', email_body).group(1)
        strategy_order_price = re.search(
            r'Order price: (.*)', email_body).group(1)
        strategy_order_id = re.search(
            r'Order ID: (.*)', email_body).group(1)
        strategy_market_position = re.search(
            r'Market position: (.*)', email_body).group(1)
        strategy_prev_market_position = re.search(
            r'Previous market position: (.*)', email_body).group(1)
        strategy_prev_market_position_size = re.search(
            r'Previous market position size: (.*)', email_body).group(1)
        strategy_account_side = re.search(
            r'Account side: (.*)', email_body).group(1)
        strategy_account_symbol = re.search(
            r'Account side: (.*)', email_body).group(1)
        strategy_account_side = re.search(
            r'Account side: (.*)', email_body).group(1)

        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()
    return "OK"

# Initialize the Bybit client
client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                     api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

# Place the order
print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
      qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())
















@app.route('/')
def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

    unseen_mails = imap_server.search(["UNSEEN"])
    if unseen_mails:
        mail_id = list(unseen_mails)[0]
        email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
        email_body = email_data.get_body().decode()
        passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
        strategy_position_size = re.search(
            r'Position size: (.*)', email_body).group(1)
        strategy_order_action = re.search(
            r'Order action: (.*)', email_body).group(1)
        strategy_order_contracts = re.search(
            r'Order contracts: (.*)', email_body).group(1)
        strategy_order_price = re.search(
            r'Order price: (.*)', email_body).group(1)
        strategy_order_id = re.search(
            r'Order ID: (.*)', email_body).group(1)
        strategy_market_position = re.search(
            r'Market position: (.*)', email_body).group(1)
        strategy_market_position_size = re.search(
            r'Market position size: (.*)', email_body).group(1)
        strategy_prev_market_position = re.search(
            r'Previous market position: (.*)', email_body).group(1)
        strategy_prev_market_position_size = re.search(
            r'Previous market position size: (.*)', email_body).group(1)

        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
    else:
        print("No messages found")

    imap_server.logout()
    return "OK"

if __name__ == '__main__':
    app.run()

# Initialize the Bybit client
client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                     api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
























app = Flask(__name__)


@app.route('/')
def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com', 993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')

    while True:
        unseen_mails = imap_server.search(["UNSEEN"])
        if unseen_mails:
            mail_id = list(unseen_mails)[0]
            email_id, email_data = imap_server.fetch(
                mail_id, 'RFC822').popitem()
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(
                r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(
                r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(
                r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(
                r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(
                r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(
                r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(
                r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(
                r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(
                r'Previous market position size: (.*)', email_body).group(1)
        else:
            print("No messages found")

        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
        time.sleep(5)
        imap_server.logout()


json_data = {
    "passphrase": "a321!",
    "timeframe": "2023-01-01T12:00:00",
    "exchange": "abc",
    "ticker": "abc_123",
    "bar": {
        "time": "2023-01-01T12:00:00",
        "open": 100.0,
        "high": 101.0,
        "low": 99.0,
        "close": 100.5,
        "volume": 1000
    },
    "strategy": {
        "position_size": 100,
        "order_action": "buy",
        "order_contracts": 5,
        "order_price": 100.0,
        "order_id": 123456,
        "market_position": "long"
    },
    "account": {
        "side": "buy",
        "symbol": "abc_123",
        "order_type": "limit",
        "qty": 5,
        "price": 100.0,
        "time_in_force": "gtc"
    }
}

data = '{"passphrase": "a321!", "timeframe": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'
# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
timeframe = json_data["timeframe"]
exchange = json_data["exchange"]
symbol = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
strategy_position_size = strategy.get("position_size", "")
strategy_order_action = strategy.get("order_action", "")
strategy_order_contracts = strategy.get("order_contracts", "")
strategy_order_price = strategy.get("order_price", "")
strategy_order_id = strategy.get("order_id", "")
strategy_market_position = strategy.get("market_position", "")
strategy_market_position_size = strategy.get("market_position_size", "")
strategy_prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
account_side = account.get("side", "")
account_symbol = account.get("symbol", "")
account_order_type = account.get("order_type", "")
account_qty = account.get("qty", 0)
account_price = account.get("price", 0.0)
account_time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Timeframe:", timeframe)
print("Exchange:", exchange)
print("Ticker:", symbol)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", strategy_position_size)
print("Order Action:", strategy_order_action)
print("Order Contracts:", strategy_order_contracts)
print("Order Price:", strategy_order_price)
print("Order ID:", strategy_order_id)
print("Market Position:", strategy_market_position)
print("Market Position Size:", strategy_market_position_size)
print("Prev Market Position:", strategy_prev_market_position)
print("Side:", account_side)
print("Symbol:", account_symbol)
print("Order Type:", account_order_type)
print("Qty:", account_qty)
print("Price:", account_price)
print("Time In Force:", account_time_in_force)
# Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()


json_data = json.loads(data)

ccount_symbol = json_data["ticker"]
account_side = account.get("side", "")
account_order_type = account.get("order_type", "")
account_qty = account.get("qty", "")
account_price = account.get("price", "")
account_time_in_force = account.get("time_in_force", "")
saccount_trategy = account.get("strategy", "")

# Initialize the Bybit client
client = bybit.bybit(test=False, api_key="76QjbsflcrBdSZiSrU",
                     api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

# Place the order
print(client.Order.Order_new(side=account_side, symbol=account_symbol, order_type=account_order_type,
      qty=account_qty, price=account_price, time_in_force=account_time_in_force).result())

# get the order ID from the response
response = client.Order.Order_getOrders(symbol=account_symbol).result()

# Cancel the order
#print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

# Cancel All Active Orders
#print(client.Order.Order_cancelAll(symbol=symbol).result())

# Replace Active Order
#print(client.Order.Order_replace(symbol=symbol,
#      order_id=order_id, qty=account_qty).result())
# Query Active Orders(real-time)
print(client.Order.Order_query(symbol=account_symbol).result())

# My Position
print(client.Positions.Positions_myPosition(symbol=account_symbol).result())

# If the order is filled, print a message
#if _myPosition == True:
#    print("Order Active")
#else:
#   print("Order not filled.")










# get the order ID from the response
response = client.Order.Order_getOrders(symbol=account_symbol).result()
order_id = response[0]["order_id"]





account_symbol = json_data["ticker"]
account_side = account.get("side", "")
account_order_type = account.get("order_type", "")
account_qty = account.get("qty", "")
account_price = account.get("price", "")
account_time_in_force = account.get("time_in_force", "")
saccount_trategy = account.get("strategy", "")












json_data = {
    "passphrase": "a321!",
    "timeframe": "2023-01-01T12:00:00",
    "exchange": "abc",
    "ticker": "abc_123",
    "bar": {
        "time": "2023-01-01T12:00:00",
        "open": 100.0,
        "high": 101.0,
        "low": 99.0,
        "close": 100.5,
        "volume": 1000
    },
    "strategy": {
        "position_size": 100,
        "order_action": "buy",
        "order_contracts": 5,
        "order_price": 100.0,
        "order_id": 123456,
        "market_position": "long"
    },
    "account": {
        "side": "buy",
        "symbol": "abc_123",
        "order_type": "limit",
        "qty": 5,
        "price": 100.0,
        "time_in_force": "gtc"
    }
}

data = '{"passphrase": "a321!", "timeframe": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'
# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
timeframe = json_data["timeframe"]
exchange = json_data["exchange"]
symbol = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
strategy_position_size = strategy.get("position_size", "")
strategy_order_action = strategy.get("order_action", "")
strategy_order_contracts = strategy.get("order_contracts", "")
strategy_order_price = strategy.get("order_price", "")
strategy_order_id = strategy.get("order_id", "")
strategy_market_position = strategy.get("market_position", "")
strategy_market_position_size = strategy.get("market_position_size", "")
strategy_prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
account_side = account.get("side", "")
account_symbol = account.get("symbol", "")
account_order_type = account.get("order_type", "")
account_qty = account.get("qty", 0)
account_price = account.get("price", 0.0)
account_time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Timeframe:", timeframe)
print("Exchange:", exchange)
print("Ticker:", symbol)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", strategy_position_size)
print("Order Action:", strategy_order_action)
print("Order Contracts:", strategy_order_contracts)
print("Order Price:", strategy_order_price)
print("Order ID:", strategy_order_id)
print("Market Position:", strategy_market_position)
print("Market Position Size:", strategy_market_position_size)
print("Prev Market Position:", strategy_prev_market_position)
print("Side:", account_side)
print("Symbol:", account_symbol)
print("Order Type:", account_order_type)
print("Qty:", account_qty)
print("Price:", account_price)
print("Time In Force:", account_time_in_force)
# Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()


json_data = json.loads(data)

account_symbol = json_data["ticker"]
account_side = json_data["side"]
account_order_type = json_data["order_type"]
account_qty = json_data["qty"]
account_price = json_data["price"]
account_time_in_force = json_data["time_in_force"]
saccount_trategy = json_data["strategy"]








json_data = {
    "passphrase": "a321!", 
    "time": "2023-01-01T12:00:00", 
    "exchange": "abc", 
    "ticker": "abc_123", 
    "bar": {
        "time": "2023-01-01T12:00:00", 
        "open": 100.0, 
        "high": 101.0, 
        "low": 99.0, 
        "close": 100.5, 
        "volume": 1000
    }, 
    "strategy": {
        "position_size": 100, 
        "order_action": "buy", 
        "order_contracts": 5, 
        "order_price": 100.0, 
        "order_id": 123456, 
        "market_position": "long"
    }, 
    "account": {
        "side": "buy", 
        "symbol": "abc_123", 
        "order_type": "limit", 
        "qty": 5, 
        "price": 100.0, 
        "time_in_force": "gtc"
    }
}
















def execute_trade():  
    imap_server = IMAPClient('imap-mail.outlook.com',993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')
    
    while True:
        unseen_mails = imap_server.search(["UNSEEN"])
        if unseen_mails:
            mail_id = list(unseen_mails)[0]
            email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(
                r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(
                r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(
                r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(
                r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(
                r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(
                r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(
                r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(
                r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(
                r'Previous market position size: (.*)', email_body).group(1)
        else:
            print("No messages found")
        
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
        time.sleep(5)
    imap_server.logout()

json_data = {
"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": { 
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
        "close": "{{close}}",
        "volume": "{{volume}}",
},
"order": {
     "side": "side",
     "symbol": "symbol",
     "type": "Limit",
     "qty": "qty",
     "price": "price",
     "time_in_force": "gtc"
},
"passphrase": "{{passphrase}}"
}

data = '{"passphrase": "a321!", "time": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'
# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
time1 = json_data["time"]
exchange = json_data["exchange"]
symbol = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
position_size = strategy.get("position_size", "")
order_action = strategy.get("order_action", "")
order_contracts = strategy.get("order_contracts", "")
order_price = strategy.get("order_price", "")
order_id = strategy.get("order_id", "")
market_position = strategy.get("market_position", "")
market_position_size = strategy.get("market_position_size", "")
prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
side = account.get("side", "")
symbol = account.get("symbol", "")
order_type = account.get("order_type", "")
qty = account.get("qty", "")
price = account.get("price", "")
time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Time:", time)
print("Exchange:", exchange)
print("Ticker:", symbol)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", position_size)
print("Order Action:", order_action)
print("Order Contracts:", order_contracts)
print("Order Price:", order_price)
print("Order ID:", order_id)
print("Market Position:", market_position)
print("Market Position Size:", market_position_size)
print("Prev Market Position:", prev_market_position)
print("Side:", side)
print("Symbol:", symbol)
print("Order Type:", order_type)
print("Qty:", qty)
print("Price:", price)
print("Time In Force:", time_in_force)
# Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()

with open("json_data") as f:
    json_data = json.load(f)

symbol = json_data["symbol"]
order_side = json_data["side"]
order_type = json_data["order_type"]
qty = json_data["qty"]
price = json_data["price"]
time_in_force = json_data["time_in_force"]
strategy = json_data["strategy"]



















with open("json_data", "r") as f:
json_data = json.load(f)

symbol = json_data["symbol"]
order_side = json_data["side"]
order_type = json_data["order_type"]
qty = json_data["qty"]
price = json_data["price"]
time_in_force = json_data["time_in_force"]
strategy = json_data["strategy"]












symbol_json_data = json.load(data)
symbol = symbol_json_data["symbol"]

with open("json_data", "r") as f:
order_side_json_data = json.load(f)
order_side = order_side_json_data["side"]

with open("json_data", "r") as f:
order_type_json_data = json.load(f)
order_type = order_type_json_data["order_type"]

with open("json_data", "r") as f:
qty_json_data = json.load(f)
qty = qty_json_data["qty"]

with open("json_data", "r") as f:
price_json_data = json.load(f)
price = price_json_data["price"]

with open("json_data", "r") as f:
time_in_force_json_data = json.load(f)
time_in_force = time_in_force_json_data["time_in_force"]

strategy = json_data["strategy"]

Initialize the Bybit client
client = bybit.bybit(test=False, api_key= "76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")

Place the order
print(client.Order.Order_new(side=order_side, symbol=symbol, order_type=order_type, qty=qty, price=price, time_in_force=time_in_force).result())

Get the order ID from the response
response = client.Order.Order_getOrders(symbol=symbol).result()
order_id = response[0]["order_id"]

Cancel the order
print(client.Order.Order_cancel(symbol=symbol, order_id=order_id).result())

Cancel All Active Orders
print(client.Order.Order_cancelAll(symbol=symbol).result())

Replace Active Order
print(client.Order.Order_replace(symbol=symbol, order_id=order_id, p_r_qty=qty).result())
#Query Active Orders(real-time)
print(client.Order.Order_query(symbol=symbol, order_id=order_id).result())

My Position
my_position = client.Positions.Positions_myPosition(symbol=symbol).result()

If the order is filled, print a message
if my_position == True:
print("Order Active")
else:
print("Order not filled.")




























symbol_json_data = json.load(data)
symbol = symbol_json_data["symbol"]

with open("json_data") as f:
     order_side_json_data = json.load(f)
     order_side = order_side_json_data["side"]

with open("json_data") as f:
    order_type_json_data = json.load(f)
    order_type = order_type_json_data["order_type"]

with open("json_data") as f:
    qty_json_data = json.load(f)
qty = qty_json_data["qty"]

with open("json_data") as f:
     price_json_data = json.load(f)
     price = price_json_data["price"]

with open("json_data") as f:
     time_in_force_json_data = json.load(f)
     time_in_force = time_in_force_json_data["time_in_force"]

strategy = json_data["strategy"]

## Initialize the Bybit client
client = bybit.bybit(test=False, api_key= "76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
print(client.Order.Order_getOrders(symbol="symbol").result())
#order_id = response[0]
# Cancel the order
# print(client.Order.Order_cancel(symbol="symbol", order_id=order_id).result())
# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol="BTCUSD").result())
# Replace Active Order
# print(client.Order.Order_replace(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec", p_r_qty="3").result())
#Query Active Orders(real-time)
#print(client.Order.Order_query(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec").result())
#status = order_details["result"]["order_status"]
# My Position
print(client.Positions.Positions_myPosition(symbol="symbol").result())
# If the order is filled, print a message
#if myPosition == True:
#    print("Order Active")
#else:
#    print("Order not filled.")














def execute_trade():  
    imap_server = IMAPClient('outlook.office365.com',993, ssl=True)
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')
    
    while True:
        unseen_mails = imap_server.search("UNSEEN")
        if unseen_mails:
            mail_id = list(unseen_mails)[0]
            email_id, email_data = imap_server.fetch(mail_id, 'RFC822').popitem()
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(
                r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(
                r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(
                r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(
                r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(
                r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(
                r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(
                r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(
                r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(
                r'Previous market position size: (.*)', email_body).group(1)
        else:
            print("No messages found")
        
        imap_server.set_flags([bytes(str(mail_id), 'utf-8')], [b'\\Seen'])
        time.sleep(5)
    imap_server.logout()

json_data = {
"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": { 
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
        "close": "{{close}}",
        "volume": "{{volume}}",
},
"order": {
     "side": "side",
     "symbol": "symbol",
     "type": "Limit",
     "qty": "qty",
     "price": "price",
     "time_in_force






















Traceback (most recent call last):
  File "/home/j/.local/bin/flask", line 8, in <module>
    sys.exit(main())
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 1047, in main
    cli.main()
  File "/usr/lib/python3/dist-packages/click/core.py", line 1053, in main
    rv = self.invoke(ctx)
  File "/usr/lib/python3/dist-packages/click/core.py", line 1659, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
  File "/usr/lib/python3/dist-packages/click/core.py", line 1395, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "/usr/lib/python3/dist-packages/click/core.py", line 754, in invoke
    return __callback(*args, **kwargs)
  File "/usr/lib/python3/dist-packages/click/decorators.py", line 84, in new_func
    return ctx.invoke(f, obj, *args, **kwargs)
  File "/usr/lib/python3/dist-packages/click/core.py", line 754, in invoke
    return __callback(*args, **kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 911, in run_command
    raise e from None
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 897, in run_command
    app = info.load_app()
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 308, in load_app
    app = locate_app(import_name, name)
  File "/home/j/.local/lib/python3.10/site-packages/flask/cli.py", line 218, in locate_app
    __import__(module_name)
  File "/home/j/py/app.py", line 152, in <module>
    with open("side.json") as f:
FileNotFoundError: [Errno 2] No such file or directory: 'side.json'


"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": { 
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
        "close": "{{close}}",
        "volume": "{{volume}}",
},
"order": {
"side": "side",
"symbol": "symbol",
"type": "Limit",
"qty": "qty",
"price": "price",
"time_in_force": "gtc"
},
"passphrase": "{{passphrase}}"
}














"timestamp": "{{timestamp}}",
"exchange": "{{exchange}}",
"symbol": "{{ticker}}",
"candle": {
"timestamp": "{{timestamp}}",
"open": "{{open}}",
"high": "{{high}}",
"low": "{{low}}",
"close": "{{close}}",
"volume": "{{volume}}",
},
"order": {
"side": "side",
"symbol": "symbol",
"type": "Limit",
"qty": "qty",
"price": "price",
"time_in_force": "gtc"
},
"passphrase": "{{passphrase}}"
}
## Initialize the Bybit client
client = bybit.bybit(test=False, api_key= "76QjbsflcrBdSZiSrU", api_secret="SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32ps")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
print(client.Order.Order_getOrders(symbol="symbol").result())
# My Position
print(client.Positions.Positions_myPosition(symbol="symbol").result())
# If the order is filled, print a message


symbol_json_data = json.load(f)
symbol = symbol_json_data["symbol"]

with open("side.json") as f:
side_json_data = json.load(f)
side = side_json_data["side"]

with open("order_type.json") as f:
order_type_json_data = json.load(f)
order_type = order_type_json_data["order_type"]

with open("qty.json") as f:
qty_json_data = json.load(f)
qty = qty_json_data["qty"]

with open("price.json") as f:
price_json_data = json.load(f)
price = price_json_data["price"]

with open("time_in_force.json") as f:
time_in_force_json_data = json.load(f)
time_in_force = time_in_force_json_data["time_in_force"]
    
symbol = json_data["symbol"]
side = json_data["side"]
order_type = json_data["order_type"]
qty = json_data["qty"]
price = json_data["price"]
time_in_force = json_data["time_in_force"]



76QjbsflcrBdSZiSr
SGAAHPUfQnTm1d1EX12ffVaizjbFA4iT32p
## Initialize the Bybit client
client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
print(client.Order.Order_getOrders(symbol="symbol").result())


client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
response = client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result()

if response.ret_code == 0:
    print("Order placed successfully")
else:
    print("Order placement failed with error code:", response.ret_code)

# Get the order ID from the response
order_list_response = client.Order.Order_getOrders(symbol="symbol").result()
if order_list_response.ret_code == 0:
    order_id = order_list_response.result[0].order_id
    print("Order ID:", order_id)
else:
    print("Order info retrieval failed with error code:", order_list_response.ret_code)


client = bybit.bybit(test=True, api_key="<your_api_key>", api_secret="<your_api_secret>")
# Place the order
print(client.Order.Order_new(side="side", symbol="symbol", order_type="order_type", qty=100, price=100, time_in_force="time_in_force").result())
# Get the order ID from the response
response = client.Order.Order_getOrders(symbol="symbol").result()
order_id = response[0]

got all these errors
({'ret_code': 10003, 'ret_msg': 'API key is invalid.', 'result': {}, 'ext_code': '', 'ext_info': '', 'time_now': '1675073367.977186', 'rate_limit_status': 0, 'rate_limit': 0, 'rate_limit_reset_ms': 0}, <bravado.requests_client.RequestsResponseAdapter object at 0x7fd50aff40d0>)
Traceback (most recent call last):
  File "/home/j/py/app.py", line 181, in <module>
    order_details = client.Order.Order_query(
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 246, in __call__
    request_params = construct_request(
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 285, in construct_request
    construct_params(operation, request, op_kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/bravado/client.py", line 308, in construct_params
    marshal_param(param, param_value, request)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/param.py", line 133, in marshal_param
    validate_schema_object(swagger_spec, param_spec, value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 68, in validate_schema_object
    validate_primitive(swagger_spec, schema_object_spec, value)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 43, in scrubbed
    reraise(*sys.exc_info())
  File "/usr/lib/python3/dist-packages/six.py", line 719, in reraise
    raise value
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 35, in scrubbed
    return func(*args, **kwargs)
  File "/home/j/.local/lib/python3.10/site-packages/bravado_core/validate.py", line 101, in validate_primitive
    ).validate(value)
  File "/home/j/.local/lib/python3.10/site-packages/jsonschema/validators.py", line 314, in validate
    raise error
jsonschema.exceptions.ValidationError: {'ret_code': 10003, 'ret_msg': 'API key is invalid.', 'result': {}, 'ext_code': '', 'ext_info': '', 'time_now': '1675073368.248223', 'rate_limit_status': 0, 'rate_limit': 0, 'rate_limit_reset_ms': 0} is not of type 'string'

Failed validating 'type' in schema:
    {'description': 'Order ID',
     'in': 'query',
     'name': 'order_id',
     'required': False,
     'type': 'string'}

On instance:
    {'ext_code': '',
     'ext_info': '',
     'rate_limit': 0,
     'rate_limit_reset_ms': 0,
     'rate_limit_status': 0,
     'result': {},
     'ret_code': 10003,
     'ret_msg': 'API key is invalid.',
     'time_now': '1675073368.248223'}

123
# Place Active Order
response = client.Order.Order_new(side="Buy",symbol="BTCUSD",order_type="Limit",qty=1,price=8300,time_in_force="GoodTillCancel")
if response.ret_code == 0:
    print("Order placed successfully")
else:
    print("Order placement failed with error code:", response.ret_code)

# Get Active Order
response = client.Order.Order_getOrders(symbol="BTCUSD")
if response.ret_code == 0:
    print("Active orders:", response.result)
else:
    print("Failed to retrieve active orders with error code:", response.ret_code)

# Cancel Active Order
order_id = "123456" # Replace with the actual order_id
response = client.Order.Order_cancel(order_id=order_id)
if response.ret_code == 0:
    print("Order cancelled successfully")
else:
    print("Order cancellation failed with error code:", response.ret_code)



unseen_mails = list(imap_server.search("UNSEEN"))
imap_server.set_flags([bytes(str(mail_id), 'utf-8') for mail_id in unseen_mails], [b'\\Seen'])



search_criteria = {'UNSEEN'}
email_ids = imap_server.search(search_criteria)

# Get the first email
email_id = email_ids[0]

# Mark the email as seen
imap_server.set_flags([email_id], [b'\\Seen'])
 
 
 
 # print(client.Order.Order_cancel(symbol="BTCUSD", order_id="a0bc44c0-6ddb-4f41-913d-fa9d5299d7c2").result())
# Cancel All Active Orders
# print(client.Order.Order_cancelAll(symbol="BTCUSD").result())
# Replace Active Order
# print(client.Order.Order_replace(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec", p_r_qty="3").result())
# Query Active Orders(real-time)
# print(client.Order.Order_query(symbol="BTCUSD", order_id="e838ebcd-77be-43e7-ae4a-9bc380bad6ec").result())
 
 
 /home/j/py/.venv/bin/python /home/j/py/app.py
Traceback (most recent call last):
  File "/home/j/py/app.py", line 79, in <module>
    data = request.data
  File "/home/j/.local/lib/python3.10/site-packages/werkzeug/local.py", line 316, in __get__
    obj = instance._get_current_object()  # type: ignore[misc]
  File "/home/j/.local/lib/python3.10/site-packages/werkzeug/local.py", line 513, in _get_current_object
    raise RuntimeError(unbound_message) from None
RuntimeError: Working outside of request context.

This typically means that you attempted to use functionality that needed
an active HTTP request. Consult the documentation on testing for
information about how to avoid this problem.

data = '{"passphrase": "xyz", "time": "2023-01-01T12:00:00", "exchange": "abc", "ticker": "abc_123", "bar": {"time": "2023-01-01T12:00:00", "open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000}, "strategy": {"position_size": 100, "order_action": "buy", "order_contracts": 5, "order_price": 100.0, "order_id": 123456, "market_position": "long", "market_position_size": 5}, "account": {"side": "buy", "symbol": "abc_123", "order_type": "limit", "qty": 5, "price": 100.0, "time_in_force": "gtc"}}'





from flask import Flask, request
import pyzmail
import json
import imapclient
import bybit
import time
import email
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/ex', methods=['POST'])
# Connect to email server
# Search for email with desired data
# search_criteria = ['SUBJECT', 'Trade Data']
# uid_list = imap_client.search(search_criteria)
# email = imap_client.fetch([uid_list[0]], ['BODY[]'])
# email_text = email[uid_list[0]][b'BODY[]'].decode()
# return email_text

def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com",993')
    imap_server.login('sterxus@outlook.com', 'TheMando321!')
    imap_server.select_folder('INBOX')
# messages = imap_server.fetch(emails, ['BODY[]'])
    while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        # messagess = imap_server.fetch(unseen_mails, ['BODY[]'])
# Search for mails with specific keyword in the subject
# emails = imap_server.search(['SUBJECT "Alert:"'])


# Process the new emails
        for email_id, email_data in imap_server.fetch(unseen_mails, 'RFC822').items():
    # Iterate through the messages
         email_body = email_data.get_body().decode()
        # Extract the relevant information from the email
         passphrase = email_body.split("Passphrase: ")[1].split("\n")[0]
         strategy_position_size = email_body.split("Position size: ")[1].split("\n")[0]
         strategy_order_action = email_body.split("Order action: ")[1].split("\n")[0]
         strategy_order_contracts = email_body.split("Order contracts: ")[1].split("\n")[0]
         strategy_order_price = email_body.split("Order price: ")[1].split("\n")[0]
         strategy_order_id = email_body.split("Order ID: ")[1].split("\n")[0]
         strategy_market_position = email_body.split("Market position: ")[1].split("\n")[0]
         strategy_market_position_size = email_body.split("Market position size: ")[1].split("\n")[0]
         strategy_prev_market_position = email_body.split("Previous market position: ")[1].split("\n")[0]
         strategy_prev_market_position_size = email_body.split("Previous market position size: ")[1].split("\n")[0]
        # Mark the message as seen
        unseen_mails.mark_seen([email_id])
        # Sleep for a few seconds before checking for new messages again
        time.sleep(5)








from flask import Flask, request
import pyzmail
import json
import imapclient
import bybit
import time
import email
import re
from imapclient import IMAPClient

app = Flask(__name__)


@app.route('/ex', methods=['POST'])
# Connect to email server
# Search for email with desired data
# search_criteria = ['SUBJECT', 'Trade Data']
# uid_list = imap_client.search(search_criteria)
# email = imap_client.fetch([uid_list[0]], ['BODY[]'])
# email_text = email[uid_list[0]][b'BODY[]'].decode()
# return email_text

def execute_trade():
    imap_server = IMAPClient('imap-mail.outlook.com",993')
    imap_server.login('', '')
    imap_server.select_folder('INBOX')
# messages = imap_server.fetch(emails, ['BODY[]'])
    while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        # messagess = imap_server.fetch(unseen_mails, ['BODY[]'])
# Search for mails with specific keyword in the subject
# emails = imap_server.search(['SUBJECT "Alert:"'])



if json_data.get("passphrase") != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()
# Extract the other information from the email
api_key = json_data["api_key"]
secret_key = json_data["secret_key"]
strategy = json_data["strategy"]

# Initialize the Bybit client
client = bybit.BybitClient(api_key=api_key, secret_key=secret_key)

# Place the order
order_response = client.Order.Order_new(side=strategy["side"], symbol=strategy["symbol"], order_type=strategy["order_type"],
                                        qty=strategy["qty"], price=strategy["price"], time_in_force=strategy["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = client.Order.Order_query(symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")

# Process the new emails
        for email_id, email_data in unseen_mails.fetch(unseen_mails, 'RFC822').items():
    # Iterate through the messages
         email_body = unseen_mails.get_body().decode()
        # Extract the relevant information from the email
         passphrase = email_body.split("Passphrase: ")[1].split("\n")[0]
         strategy_position_size = email_body.split("Position size: ")[1].split("\n")[0]
         strategy_order_action = email_body.split("Order action: ")[1].split("\n")[0]
         strategy_order_contracts = email_body.split("Order contracts: ")[1].split("\n")[0]
         strategy_order_price = email_body.split("Order price: ")[1].split("\n")[0]
         strategy_order_id = email_body.split("Order ID: ")[1].split("\n")[0]
         strategy_market_position = email_body.split("Market position: ")[1].split("\n")[0]
         strategy_market_position_size = email_body.split("Market position size: ")[1].split("\n")[0]
         strategy_prev_market_position = email_body.split("Previous market position: ")[1].split("\n")[0]
         strategy_prev_market_position_size = email_body.split("Previous market position size: ")[1].split("\n")[0]
        # Mark the message as seen
        unseen_mails.mark_seen([email_id])
        # Sleep for a few seconds before checking for new messages again
        time.sleep(5)
    # Log out of the email server
    # # imap_server.logout()
    # Define json data
json_data = {
    "passphrase": "{{passphrase}}",
    "time": "{{timenow}}",
    "exchange": "{{exchange}}",
    "ticker": "{{ticker}}",
    "bar": {
        "time": "{{ticker}}",
        "open": "{{open}}",
        "high": "{{high}}",
        "low": "{{low}}",
            "close": "{{close}}",
            "volume": "{{volume}}",
        },
        "strategy": {
            "side": "side",
            "symbol": "symbol",
            "order_type": "Limit",
            "qty": "qty",
            "price": "price",
            "time_in_force": "GoodTillCancel"
        }
}
    # Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
request =json.loads(json_data)
if "passphrase" != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
# Check if the passphrase in the email matches the passphrase in the json data
# if passphrase != json_data["passphrase"]:
#   else return "Error: Incorrect passphrase."

# Extract the other information from the email
# Initialize the Bybit client
client = bybit.BybitClient(api_key='YOUR_API_KEY',
                           secret_key='YOUR_SECRET_KEY')

# Authenticate using your API key
# client.authenticate(api_key=json_data["api_key"], secret_key=json_data["secret_key"])

# Place the order
order_response = client.Order.Order_new(side=json_data["strategy"]["side"], symbol=json_data["strategy"]["symbol"], order_type=json_data["strategy"]
                                        ["order_type"], qty=json_data["strategy"]["qty"], price=json_data["strategy"]["price"], time_in_force=json_data["strategy"]["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = bybit.Order.Order_query(
    symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    # Check if the passphrase in the email matches the expected passphrase
expected_passphrase = "a321!"
if json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    return

# Extract the other information from the email
api_key = json_data["api_key"]
secret_key = json_data["secret_key"]
strategy = json_data["strategy"]

# Initialize the Bybit client
client = bybit.BybitClient(api_key=api_key, secret_key=secret_key)

# Place the order
order_response = client.Order.Order_new(side=strategy["side"], symbol=strategy["symbol"], order_type=strategy["order_type"],
                                        qty=strategy["qty"], price=strategy["price"], time_in_force=strategy["time_in_force"]).result()

# Print the response
print(order_response)

# Get the order ID from the response
order_id = order_response["result"]["order_id"]

# Get the order details
order_details = client.Order.Order_query(symbol=json_data["ticker"], order_id=order_id).result()

# Print the order details
print(order_details)

# Check the status of the order
status = order_details["result"]["order_status"]

# If the order is filled, print a message
if status == "Filled":
    print("Order filled!")
else:
    print("Order not filled.")
    
    
    
    
    
    
    
    
    
    
    
    
    json_data = {
    "passphrase": "a321!",
    "time": "2023-01-30T12:00:00Z",
    "exchange": "NYSEMkt",
    "ticker": "AAPL",
    "bar": {
        "time": "2023-01-30T12:00:00Z",
        "open": 132.5,
        "high": 135.0,
        "low": 131.0,
        "close": 132.0,
        "volume": 100000
    },
    "strategy": {
        "position_size": 10,
        "order_action": "buy",
        "order_contracts": 10,
        "order_price": 132.0,
        "order_id": "Close position order",
        "market_position": "long",
        "market_position_size": 10,
        "prev_market_position": "short"
    },
    "account": {
        "side": "buy",
        "symbol": "AAPL",
        "order_type": "Limit",
        "qty": 100,
        "price": 132.0,
        "time_in_force": "GoodTillCancel"
    }
}
    
    
    
    
    


# Load the data
json_data = json.loads(data)

# Access the values in the dictionary
passphrase = json_data["passphrase"]
time = json_data["time"]
exchange = json_data["exchange"]
ticker = json_data["ticker"]
bar = json_data["bar"]
strategy = json_data.get("strategy", {})
account = json_data.get("account", {})

# Access the values within the bar dictionary
bar_time = bar["time"]
bar_open = bar["open"]
bar_high = bar["high"]
bar_low = bar["low"]
bar_close = bar["close"]
bar_volume = bar["volume"]

# Access the values within the strategy dictionary
position_size = strategy.get("position_size", "")
order_action = strategy.get("order_action", "")
order_contracts = strategy.get("order_contracts", "")
order_price = strategy.get("order_price", "")
order_id = strategy.get("order_id", "")
market_position = strategy.get("market_position", "")
market_position_size = strategy.get("market_position_size", "")
prev_market_position = strategy.get("prev_market_position", "")

# Access the values within the account dictionary
side = account.get("side", "")
symbol = account.get("symbol", "")
order_type = account.get("order_type", "")
qty = account.get("qty", "")
price = account.get("price", "")
time_in_force = account.get("time_in_force", "")

# Print the values
print("Passphrase:", passphrase)
print("Time:", time)
print("Exchange:", exchange)
print("Ticker:", ticker)
print("Bar Time:", bar_time)
print("Bar Open:", bar_open)
print("Bar High:", bar_high)
print("Bar Low:", bar_low)
print("Bar Close:", bar_close)
print("Bar Volume:", bar_volume)
print("Position Size:", position_size)
print("Order Action:", order_action)
print("Order Contracts:", order_contracts)
print("Order Price:", order_price)
print("Order ID:", order_id)
print("Market Position:", market_position)
print("Market Position Size:", market_position_size)
print("Prev Market Position:", prev_market_position)
print("Side:", side)
print("Symbol:", symbol)
print("Order Type:", order_type)
print("Qty:", qty)
print("Price:", price)
print("Time In Force:", time_in_force)



expected_passphrase = "a321!"
if "passphrase" in json_data and json_data["passphrase"] != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()




expected_passphrase = "a321!"
passphrase = json_data.get("passphrase", None)
if passphrase != expected_passphrase:
    print("Invalid passphrase. Trade not executed.")
    exit()
    
    
    
    
    
    
    
    
    
    
    
        while True:
        unseen_mails = imap_server.search(['UNSEEN'])
        for email_id, email_data in imap_server.fetch(unseen_mails, 'RFC822').items():
            email_body = email_data.get_body().decode()
            passphrase = re.search(r'Passphrase: (.*)', email_body).group(1)
            strategy_position_size = re.search(r'Position size: (.*)', email_body).group(1)
            strategy_order_action = re.search(r'Order action: (.*)', email_body).group(1)
            strategy_order_contracts = re.search(r'Order contracts: (.*)', email_body).group(1)
            strategy_order_price = re.search(r'Order price: (.*)', email_body).group(1)
            strategy_order_id = re.search(r'Order ID: (.*)', email_body).group(1)
            strategy_market_position = re.search(r'Market position: (.*)', email_body).group(1)
            strategy_market_position_size = re.search(r'Market position size: (.*)', email_body).group(1)
            strategy_prev_market_position = re.search(r'Previous market position: (.*)', email_body).group(1)
            strategy_prev_market_position_size = re.search(r'Previous market position size: (.*)', email_body).group(1)
        imap_server.mark_seen([email_id])
        time.sleep(5)
